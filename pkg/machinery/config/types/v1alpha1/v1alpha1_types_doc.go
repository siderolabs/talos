// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by hack/docgen tool. DO NOT EDIT.

package v1alpha1

import (
	"github.com/siderolabs/go-pointer"

	"github.com/siderolabs/talos/pkg/machinery/config/encoder"
	"github.com/siderolabs/talos/pkg/machinery/constants"
)

func (Config) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Config",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Config defines the v1alpha1.Config Talos machine configuration document." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Config defines the v1alpha1.Config Talos machine configuration document.",
		Fields: []encoder.Doc{
			{
				Name:        "version",
				Type:        "string",
				Note:        "",
				Description: "Indicates the schema used to decode the contents.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates the schema used to decode the contents." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"v1alpha1",
				},
			},
			{
				Name:        "debug",
				Type:        "bool",
				Note:        "",
				Description: "Enable verbose logging to the console.\nAll system containers logs will flow into serial console.\n\n**Note:** To avoid breaking Talos bootstrap flow enable this option only if serial console can handle high message throughput.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable verbose logging to the console." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
			{},
			{
				Name:        "machine",
				Type:        "MachineConfig",
				Note:        "",
				Description: "Provides machine specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Provides machine specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "cluster",
				Type:        "ClusterConfig",
				Note:        "",
				Description: "Provides cluster specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Provides cluster specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", configExample())

	return doc
}

func (MachineConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineConfig represents the machine-specific config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineConfig represents the machine-specific config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Config",
				FieldName: "machine",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "type",
				Type:        "string",
				Note:        "",
				Description: "Defines the role of the machine within the cluster.\n\n**Control Plane**\n\nControl Plane node type designates the node as a control plane member.\nThis means it will host etcd along with the Kubernetes controlplane components such as API Server, Controller Manager, Scheduler.\n\n**Worker**\n\nWorker node type designates the node as a worker node.\nThis means it will be an available compute node for scheduling workloads.\n\nThis node type was previously known as \"join\"; that value is still supported but deprecated.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the role of the machine within the cluster." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"controlplane",
					"worker",
				},
			},
			{
				Name:        "token",
				Type:        "string",
				Note:        "Warning: It is important to ensure that this token is correct since a machine's certificate has a short TTL by default.\n",
				Description: "The `token` is used by a machine to join the PKI of the cluster.\nUsing this token, a machine will create a certificate signing request (CSR), and request a certificate that will be used as its' identity.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `token` is used by a machine to join the PKI of the cluster." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ca",
				Type:        "PEMEncodedCertificateAndKey",
				Note:        "",
				Description: "The root certificate authority of the PKI.\nIt is composed of a base64 encoded `crt` and `key`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The root certificate authority of the PKI." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "acceptedCAs",
				Type:        "[]PEMEncodedCertificate",
				Note:        "",
				Description: "The certificates issued by certificate authorities are accepted in addition to issuing 'ca'.\nIt is composed of a base64 encoded `crt``.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The certificates issued by certificate authorities are accepted in addition to issuing 'ca'." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "certSANs",
				Type:        "[]string",
				Note:        "",
				Description: "Extra certificate subject alternative names for the machine's certificate.\nBy default, all non-loopback interface IPs are automatically added to the certificate's SANs.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra certificate subject alternative names for the machine's certificate." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "controlPlane",
				Type:        "MachineControlPlaneConfig",
				Note:        "",
				Description: "Provides machine specific control plane configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Provides machine specific control plane configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kubelet",
				Type:        "KubeletConfig",
				Note:        "",
				Description: "Used to provide additional options to the kubelet.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to provide additional options to the kubelet." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "pods",
				Type:        "[]Unstructured",
				Note:        "",
				Description: "Used to provide static pod definitions to be run by the kubelet directly bypassing the kube-apiserver.\n\nStatic pods can be used to run components which should be started before the Kubernetes control plane is up.\nTalos doesn't validate the pod definition.\nUpdates to this field can be applied without a reboot.\n\nSee https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to provide static pod definitions to be run by the kubelet directly bypassing the kube-apiserver." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "network",
				Type:        "NetworkConfig",
				Note:        "",
				Description: "Provides machine specific network configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Provides machine specific network configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "disks",
				Type:        "[]MachineDisk",
				Note:        "Note: `size` is in units of bytes.\n",
				Description: "Used to partition, format and mount additional disks.\nSince the rootfs is read only with the exception of `/var`, mounts are only valid if they are under `/var`.\nNote that the partitioning and formatting is done only once, if and only if no existing XFS partitions are found.\nIf `size:` is omitted, the partition is sized to occupy the full disk.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to partition, format and mount additional disks." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "install",
				Type:        "InstallConfig",
				Note:        "",
				Description: "Used to provide instructions for installations.\n\nNote that this configuration section gets silently ignored by Talos images that are considered pre-installed.\nTo make sure Talos installs according to the provided configuration, Talos should be booted with ISO or PXE-booted.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to provide instructions for installations." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "files",
				Type:        "[]MachineFile",
				Note:        "Note: The specified `path` is relative to `/var`.\n",
				Description: "Allows the addition of user specified files.\nThe value of `op` can be `create`, `overwrite`, or `append`.\nIn the case of `create`, `path` must not exist.\nIn the case of `overwrite`, and `append`, `path` must be a valid file.\nIf an `op` value of `append` is used, the existing file will be appended.\nNote that the file contents are not required to be base64 encoded.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Allows the addition of user specified files." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "env",
				Type:        "Env",
				Note:        "",
				Description: "The `env` field allows for the addition of environment variables.\nAll environment variables are set on PID 1 in addition to every service.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `env` field allows for the addition of environment variables." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"`GRPC_GO_LOG_VERBOSITY_LEVEL`",
					"`GRPC_GO_LOG_SEVERITY_LEVEL`",
					"`http_proxy`",
					"`https_proxy`",
					"`no_proxy`",
				},
			},
			{
				Name:        "time",
				Type:        "TimeConfig",
				Note:        "",
				Description: "Used to configure the machine's time settings.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to configure the machine's time settings." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "sysctls",
				Type:        "map[string]string",
				Note:        "",
				Description: "Used to configure the machine's sysctls.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to configure the machine's sysctls." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "sysfs",
				Type:        "map[string]string",
				Note:        "",
				Description: "Used to configure the machine's sysfs.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to configure the machine's sysfs." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "registries",
				Type:        "RegistriesConfig",
				Note:        "",
				Description: "Used to configure the machine's container image registry mirrors.\n\nAutomatically generates matching CRI configuration for registry mirrors.\n\nThe `mirrors` section allows to redirect requests for images to a non-default registry,\nwhich might be a local registry or a caching mirror.\n\nThe `config` section provides a way to authenticate to the registry with TLS client\nidentity, provide registry CA, or authentication information.\nAuthentication information has same meaning with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).\n\nSee also matching configuration for [CRI containerd plugin](https://github.com/containerd/cri/blob/master/docs/registry.md).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to configure the machine's container image registry mirrors." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "systemDiskEncryption",
				Type:        "SystemDiskEncryptionConfig",
				Note:        "",
				Description: "Machine system disk encryption configuration.\nDefines each system partition encryption parameters.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Machine system disk encryption configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "features",
				Type:        "FeaturesConfig",
				Note:        "",
				Description: "Features describe individual Talos features that can be switched on or off.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Features describe individual Talos features that can be switched on or off." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "udev",
				Type:        "UdevConfig",
				Note:        "",
				Description: "Configures the udev system.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the udev system." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "logging",
				Type:        "LoggingConfig",
				Note:        "",
				Description: "Configures the logging system.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the logging system." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kernel",
				Type:        "KernelConfig",
				Note:        "",
				Description: "Configures the kernel.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the kernel." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "seccompProfiles",
				Type:        "[]MachineSeccompProfile",
				Note:        "",
				Description: "Configures the seccomp profiles for the machine.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the seccomp profiles for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "nodeLabels",
				Type:        "map[string]string",
				Note:        "",
				Description: "Configures the node labels for the machine.\n\nNote: In the default Kubernetes configuration, worker nodes are restricted to set\nlabels with some prefixes (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the node labels for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "nodeAnnotations",
				Type:        "map[string]string",
				Note:        "",
				Description: "Configures the node annotations for the machine.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the node annotations for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "nodeTaints",
				Type:        "map[string]string",
				Note:        "",
				Description: "Configures the node taints for the machine. Effect is optional.\n\nNote: In the default Kubernetes configuration, worker nodes are not allowed to\nmodify the taints (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the node taints for the machine. Effect is optional." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineConfigExample())

	doc.Fields[1].AddExample("example token", "328hom.uqjzh6jnn2eie9oi")
	doc.Fields[2].AddExample("machine CA example", pemEncodedCertificateExample())
	doc.Fields[4].AddExample("Uncomment this to enable SANs.", []string{"10.0.0.10", "172.16.0.10", "192.168.0.10"})
	doc.Fields[5].AddExample("ControlPlane definition example.", machineControlplaneExample())
	doc.Fields[6].AddExample("Kubelet definition example.", machineKubeletExample())
	doc.Fields[7].AddExample("nginx static pod.", machinePodsExample())
	doc.Fields[8].AddExample("Network definition example.", machineNetworkConfigExample())
	doc.Fields[9].AddExample("MachineDisks list example.", machineDisksExample())
	doc.Fields[10].AddExample("MachineInstall config usage example.", machineInstallExample())
	doc.Fields[11].AddExample("MachineFiles usage example.", machineFilesExample())
	doc.Fields[12].AddExample("Environment variables definition examples.", machineEnvExamples0())
	doc.Fields[12].AddExample("", machineEnvExamples1())
	doc.Fields[12].AddExample("", machineEnvExamples2())
	doc.Fields[13].AddExample("Example configuration for cloudflare ntp server.", machineTimeExample())
	doc.Fields[14].AddExample("MachineSysctls usage example.", machineSysctlsExample())
	doc.Fields[15].AddExample("MachineSysfs usage example.", machineSysfsExample())
	doc.Fields[16].AddExample("", machineConfigRegistriesExample())
	doc.Fields[17].AddExample("", machineSystemDiskEncryptionExample())
	doc.Fields[18].AddExample("", machineFeaturesExample())
	doc.Fields[19].AddExample("", machineUdevExample())
	doc.Fields[20].AddExample("", machineLoggingExample())
	doc.Fields[21].AddExample("", machineKernelExample())
	doc.Fields[22].AddExample("", machineSeccompExample())
	doc.Fields[23].AddExample("node labels example.", map[string]string{"exampleLabel": "exampleLabelValue"})
	doc.Fields[24].AddExample("node annotations example.", map[string]string{"customer.io/rack": "r13a25"})
	doc.Fields[25].AddExample("node taints example.", map[string]string{"exampleTaint": "exampleTaintValue:NoSchedule"})

	return doc
}

func (MachineSeccompProfile) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineSeccompProfile",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineSeccompProfile defines seccomp profiles for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineSeccompProfile defines seccomp profiles for the machine.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "seccompProfiles",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "The `name` field is used to provide the file name of the seccomp profile.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `name` field is used to provide the file name of the seccomp profile." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "value",
				Type:        "Unstructured",
				Note:        "",
				Description: "The `value` field is used to provide the seccomp profile.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `value` field is used to provide the seccomp profile." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineSeccompExample())

	return doc
}

func (ClusterConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ClusterConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ClusterConfig represents the cluster-wide config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ClusterConfig represents the cluster-wide config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Config",
				FieldName: "cluster",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "id",
				Type:        "string",
				Note:        "",
				Description: "Globally unique identifier for this cluster (base64 encoded random 32 bytes).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Globally unique identifier for this cluster (base64 encoded random 32 bytes)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "secret",
				Type:        "string",
				Note:        "",
				Description: "Shared secret of cluster (base64 encoded random 32 bytes).\nThis secret is shared among cluster members but should never be sent over the network.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Shared secret of cluster (base64 encoded random 32 bytes)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "controlPlane",
				Type:        "ControlPlaneConfig",
				Note:        "",
				Description: "Provides control plane specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Provides control plane specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "clusterName",
				Type:        "string",
				Note:        "",
				Description: "Configures the cluster's name.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures the cluster's name." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "network",
				Type:        "ClusterNetworkConfig",
				Note:        "",
				Description: "Provides cluster specific network configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Provides cluster specific network configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "token",
				Type:        "string",
				Note:        "",
				Description: "The [bootstrap token](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) used to join the cluster.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The [bootstrap token](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) used to join the cluster." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "aescbcEncryptionSecret",
				Type:        "string",
				Note:        "",
				Description: "A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).\nEnables encryption with AESCBC.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "secretboxEncryptionSecret",
				Type:        "string",
				Note:        "",
				Description: "A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).\nEnables encryption with secretbox.\nSecretbox has precedence over AESCBC.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ca",
				Type:        "PEMEncodedCertificateAndKey",
				Note:        "",
				Description: "The base64 encoded root certificate authority used by Kubernetes.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The base64 encoded root certificate authority used by Kubernetes." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "acceptedCAs",
				Type:        "[]PEMEncodedCertificate",
				Note:        "",
				Description: "The list of base64 encoded accepted certificate authorities used by Kubernetes.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The list of base64 encoded accepted certificate authorities used by Kubernetes." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "aggregatorCA",
				Type:        "PEMEncodedCertificateAndKey",
				Note:        "",
				Description: "The base64 encoded aggregator certificate authority used by Kubernetes for front-proxy certificate generation.\n\nThis CA can be self-signed.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The base64 encoded aggregator certificate authority used by Kubernetes for front-proxy certificate generation." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "serviceAccount",
				Type:        "PEMEncodedKey",
				Note:        "",
				Description: "The base64 encoded private key for service account token generation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The base64 encoded private key for service account token generation." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "apiServer",
				Type:        "APIServerConfig",
				Note:        "",
				Description: "API server specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "API server specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "controllerManager",
				Type:        "ControllerManagerConfig",
				Note:        "",
				Description: "Controller manager server specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Controller manager server specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "proxy",
				Type:        "ProxyConfig",
				Note:        "",
				Description: "Kube-proxy server-specific configuration options",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Kube-proxy server-specific configuration options" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "scheduler",
				Type:        "SchedulerConfig",
				Note:        "",
				Description: "Scheduler server specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Scheduler server specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "discovery",
				Type:        "ClusterDiscoveryConfig",
				Note:        "",
				Description: "Configures cluster member discovery.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures cluster member discovery." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "etcd",
				Type:        "EtcdConfig",
				Note:        "",
				Description: "Etcd specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Etcd specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "coreDNS",
				Type:        "CoreDNS",
				Note:        "",
				Description: "Core DNS specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Core DNS specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "externalCloudProvider",
				Type:        "ExternalCloudProviderConfig",
				Note:        "",
				Description: "External cloud provider configuration.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "External cloud provider configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraManifests",
				Type:        "[]string",
				Note:        "",
				Description: "A list of urls that point to additional manifests.\nThese will get automatically deployed as part of the bootstrap.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A list of urls that point to additional manifests." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraManifestHeaders",
				Type:        "map[string]string",
				Note:        "",
				Description: "A map of key value pairs that will be added while fetching the extraManifests.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A map of key value pairs that will be added while fetching the extraManifests." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "inlineManifests",
				Type:        "[]ClusterInlineManifest",
				Note:        "",
				Description: "A list of inline Kubernetes manifests.\nThese will get automatically deployed as part of the bootstrap.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A list of inline Kubernetes manifests." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "adminKubeconfig",
				Type:        "AdminKubeconfigConfig",
				Note:        "",
				Description: "Settings for admin kubeconfig generation.\nCertificate lifetime can be configured.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Settings for admin kubeconfig generation." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{},
			{
				Name:        "allowSchedulingOnControlPlanes",
				Type:        "bool",
				Note:        "",
				Description: "Allows running workload on control-plane nodes.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Allows running workload on control-plane nodes." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
		},
	}

	doc.AddExample("", clusterConfigExample())

	doc.Fields[2].AddExample("Setting controlplane endpoint address to 1.2.3.4 and port to 443 example.", clusterControlPlaneExample())
	doc.Fields[4].AddExample("Configuring with flannel CNI and setting up subnets.", clusterNetworkExample())
	doc.Fields[5].AddExample("Bootstrap token example (do not use in production!).", "wlzjyw.bei2zfylhs2by0wd")
	doc.Fields[6].AddExample("Decryption secret example (do not use in production!).", "z01mye6j16bspJYtTB/5SFX8j7Ph4JXxM2Xuu4vsBPM=")
	doc.Fields[7].AddExample("Decryption secret example (do not use in production!).", "z01mye6j16bspJYtTB/5SFX8j7Ph4JXxM2Xuu4vsBPM=")
	doc.Fields[8].AddExample("ClusterCA example.", pemEncodedCertificateExample())
	doc.Fields[10].AddExample("AggregatorCA example.", pemEncodedCertificateExample())
	doc.Fields[11].AddExample("AggregatorCA example.", pemEncodedKeyExample())
	doc.Fields[12].AddExample("", clusterAPIServerExample())
	doc.Fields[13].AddExample("", clusterControllerManagerExample())
	doc.Fields[14].AddExample("", clusterProxyExample())
	doc.Fields[15].AddExample("", clusterSchedulerExample())
	doc.Fields[16].AddExample("", clusterDiscoveryExample())
	doc.Fields[17].AddExample("", clusterEtcdExample())
	doc.Fields[18].AddExample("", clusterCoreDNSExample())
	doc.Fields[19].AddExample("", clusterExternalCloudProviderConfigExample())
	doc.Fields[20].AddExample("", []string{
		"https://www.example.com/manifest1.yaml",
		"https://www.example.com/manifest2.yaml",
	})
	doc.Fields[21].AddExample("", map[string]string{
		"Token":       "1234567",
		"X-ExtraInfo": "info",
	})
	doc.Fields[22].AddExample("", clusterInlineManifestsExample())
	doc.Fields[23].AddExample("", clusterAdminKubeconfigExample())
	doc.Fields[25].AddExample("", true)

	return doc
}

func (LinuxIDMapping) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "LinuxIDMapping",
		Comments:    [3]string{"" /* encoder.HeadComment */, "LinuxIDMapping represents the Linux ID mapping." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "LinuxIDMapping represents the Linux ID mapping.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ExtraMount",
				FieldName: "uidMappings",
			},
			{
				TypeName:  "ExtraMount",
				FieldName: "gidMappings",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "containerID",
				Type:        "uint32",
				Note:        "",
				Description: "ContainerID is the starting UID/GID in the container.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "ContainerID is the starting UID/GID in the container." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "hostID",
				Type:        "uint32",
				Note:        "",
				Description: "HostID is the starting UID/GID on the host to be mapped to 'ContainerID'.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "HostID is the starting UID/GID on the host to be mapped to 'ContainerID'." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "size",
				Type:        "uint32",
				Note:        "",
				Description: "Size is the number of IDs to be mapped.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Size is the number of IDs to be mapped." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (ExtraMount) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ExtraMount",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ExtraMount wraps OCI Mount specification." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ExtraMount wraps OCI Mount specification.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "KubeletConfig",
				FieldName: "extraMounts",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "destination",
				Type:        "string",
				Note:        "",
				Description: "Destination is the absolute path where the mount will be placed in the container.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Destination is the absolute path where the mount will be placed in the container." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "type",
				Type:        "string",
				Note:        "",
				Description: "Type specifies the mount kind.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Type specifies the mount kind." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "source",
				Type:        "string",
				Note:        "",
				Description: "Source specifies the source path of the mount.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Source specifies the source path of the mount." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "options",
				Type:        "[]string",
				Note:        "",
				Description: "Options are fstab style mount options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Options are fstab style mount options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "uidMappings",
				Type:        "[]LinuxIDMapping",
				Note:        "",
				Description: "UID/GID mappings used for changing file owners w/o calling chown, fs should support it.\n\nEvery mount point could have its own mapping.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "UID/GID mappings used for changing file owners w/o calling chown, fs should support it." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "gidMappings",
				Type:        "[]LinuxIDMapping",
				Note:        "",
				Description: "UID/GID mappings used for changing file owners w/o calling chown, fs should support it.\n\nEvery mount point could have its own mapping.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "UID/GID mappings used for changing file owners w/o calling chown, fs should support it." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", kubeletExtraMountsExample())

	return doc
}

func (MachineControlPlaneConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineControlPlaneConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineControlPlaneConfig machine specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineControlPlaneConfig machine specific configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "controlPlane",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "controllerManager",
				Type:        "MachineControllerManagerConfig",
				Note:        "",
				Description: "Controller manager machine specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Controller manager machine specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "scheduler",
				Type:        "MachineSchedulerConfig",
				Note:        "",
				Description: "Scheduler machine specific configuration options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Scheduler machine specific configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("ControlPlane definition example.", machineControlplaneExample())

	return doc
}

func (MachineControllerManagerConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineControllerManagerConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineControllerManagerConfig represents the machine specific ControllerManager config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineControllerManagerConfig represents the machine specific ControllerManager config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineControlPlaneConfig",
				FieldName: "controllerManager",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Disable kube-controller-manager on the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable kube-controller-manager on the node." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (MachineSchedulerConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineSchedulerConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineSchedulerConfig represents the machine specific Scheduler config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineSchedulerConfig represents the machine specific Scheduler config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineControlPlaneConfig",
				FieldName: "scheduler",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Disable kube-scheduler on the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable kube-scheduler on the node." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (KubeletConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KubeletConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KubeletConfig represents the kubelet config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KubeletConfig represents the kubelet config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "kubelet",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The `image` field is an optional reference to an alternative kubelet image.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `image` field is an optional reference to an alternative kubelet image." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "clusterDNS",
				Type:        "[]string",
				Note:        "",
				Description: "The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraArgs",
				Type:        "map[string]string",
				Note:        "",
				Description: "The `extraArgs` field is used to provide additional flags to the kubelet.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `extraArgs` field is used to provide additional flags to the kubelet." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraMounts",
				Type:        "[]ExtraMount",
				Note:        "",
				Description: "The `extraMounts` field is used to add additional mounts to the kubelet container.\nNote that either `bind` or `rbind` are required in the `options`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `extraMounts` field is used to add additional mounts to the kubelet container." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraConfig",
				Type:        "Unstructured",
				Note:        "",
				Description: "The `extraConfig` field is used to provide kubelet configuration overrides.\n\nSome fields are not allowed to be overridden: authentication and authorization, cgroups\nconfiguration, ports, etc.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `extraConfig` field is used to provide kubelet configuration overrides." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "credentialProviderConfig",
				Type:        "Unstructured",
				Note:        "",
				Description: "The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "defaultRuntimeSeccompProfileEnabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable container runtime default Seccomp profile.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable container runtime default Seccomp profile." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
			{
				Name:        "registerWithFQDN",
				Type:        "bool",
				Note:        "",
				Description: "The `registerWithFQDN` field is used to force kubelet to use the node FQDN for registration.\nThis is required in clouds like AWS.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `registerWithFQDN` field is used to force kubelet to use the node FQDN for registration." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
			{
				Name:        "nodeIP",
				Type:        "KubeletNodeIPConfig",
				Note:        "",
				Description: "The `nodeIP` field is used to configure `--node-ip` flag for the kubelet.\nThis is used when a node has multiple addresses to choose from.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `nodeIP` field is used to configure `--node-ip` flag for the kubelet." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "skipNodeRegistration",
				Type:        "bool",
				Note:        "",
				Description: "The `skipNodeRegistration` is used to run the kubelet without registering with the apiserver.\nThis runs kubelet as standalone and only runs static pods.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `skipNodeRegistration` is used to run the kubelet without registering with the apiserver." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
			{
				Name:        "disableManifestsDirectory",
				Type:        "bool",
				Note:        "",
				Description: "The `disableManifestsDirectory` field configures the kubelet to get static pod manifests from the /etc/kubernetes/manifests directory.\nIt's recommended to configure static pods with the \"pods\" key instead.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `disableManifestsDirectory` field configures the kubelet to get static pod manifests from the /etc/kubernetes/manifests directory." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
		},
	}

	doc.AddExample("Kubelet definition example.", machineKubeletExample())

	doc.Fields[0].AddExample("", kubeletImageExample())
	doc.Fields[1].AddExample("", []string{"10.96.0.10", "169.254.2.53"})
	doc.Fields[2].AddExample("", map[string]string{
		"key": "value",
	})
	doc.Fields[3].AddExample("", kubeletExtraMountsExample())
	doc.Fields[4].AddExample("", kubeletExtraConfigExample())
	doc.Fields[5].AddExample("", kubeletCredentialProviderConfigExample())
	doc.Fields[8].AddExample("", kubeletNodeIPExample())

	return doc
}

func (KubeletNodeIPConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KubeletNodeIPConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KubeletNodeIPConfig represents the kubelet node IP configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KubeletNodeIPConfig represents the kubelet node IP configuration.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "KubeletConfig",
				FieldName: "nodeIP",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "validSubnets",
				Type:        "[]string",
				Note:        "",
				Description: "The `validSubnets` field configures the networks to pick kubelet node IP from.\nFor dual stack configuration, there should be two subnets: one for IPv4, another for IPv6.\nIPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.\nNegative subnet matches should be specified last to filter out IPs picked by positive matches.\nIf not specified, node IP is picked based on cluster podCIDRs: IPv4/IPv6 address or both.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `validSubnets` field configures the networks to pick kubelet node IP from." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", kubeletNodeIPExample())

	return doc
}

func (NetworkConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "NetworkConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "NetworkConfig represents the machine's networking config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "NetworkConfig represents the machine's networking config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "network",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "hostname",
				Type:        "string",
				Note:        "",
				Description: "Used to statically set the hostname for the machine.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to statically set the hostname for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "interfaces",
				Type:        "[]Device",
				Note:        "",
				Description: "`interfaces` is used to define the network interface configuration.\nBy default all network interfaces will attempt a DHCP discovery.\nThis can be further tuned through this configuration parameter.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "`interfaces` is used to define the network interface configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "nameservers",
				Type:        "[]string",
				Note:        "",
				Description: "Used to statically set the nameservers for the machine.\nDefaults to `1.1.1.1` and `8.8.8.8`",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Used to statically set the nameservers for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraHostEntries",
				Type:        "[]ExtraHost",
				Note:        "",
				Description: "Allows for extra entries to be added to the `/etc/hosts` file",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Allows for extra entries to be added to the `/etc/hosts` file" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kubespan",
				Type:        "NetworkKubeSpan",
				Note:        "",
				Description: "Configures KubeSpan feature.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures KubeSpan feature." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "disableSearchDomain",
				Type:        "bool",
				Note:        "",
				Description: "Disable generating a default search domain in /etc/resolv.conf\nbased on the machine hostname.\nDefaults to `false`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable generating a default search domain in /etc/resolv.conf" /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
		},
	}

	doc.AddExample("Network definition example.", machineNetworkConfigExample())

	doc.Fields[1].AddExample("", machineNetworkConfigExample().NetworkInterfaces)
	doc.Fields[2].AddExample("", []string{"8.8.8.8", "1.1.1.1"})
	doc.Fields[3].AddExample("", networkConfigExtraHostsExample())
	doc.Fields[4].AddExample("", networkKubeSpanExample())

	return doc
}

func (InstallConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "InstallConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "InstallConfig represents the installation options for preparing a node." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "InstallConfig represents the installation options for preparing a node.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "install",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disk",
				Type:        "string",
				Note:        "",
				Description: "The disk used for installations.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The disk used for installations." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "diskSelector",
				Type:        "InstallDiskSelector",
				Note:        "",
				Description: "Look up disk using disk attributes like model, size, serial and others.\nAlways has priority over `disk`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Look up disk using disk attributes like model, size, serial and others." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraKernelArgs",
				Type:        "[]string",
				Note:        "",
				Description: "Allows for supplying extra kernel args via the bootloader.\nExisting kernel args can be removed by prefixing the argument with a `-`.\nFor example `-console` removes all `console=<value>` arguments, whereas `-console=tty0` removes the `console=tty0` default argument.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Allows for supplying extra kernel args via the bootloader." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "Allows for supplying the image used to perform the installation.\nImage reference for each Talos release can be found on\n[GitHub releases page](https://github.com/siderolabs/talos/releases).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Allows for supplying the image used to perform the installation." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extensions",
				Type:        "[]InstallExtensionConfig",
				Note:        "",
				Description: "Allows for supplying additional system extension images to install on top of base Talos image.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Allows for supplying additional system extension images to install on top of base Talos image." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{},
			{
				Name:        "wipe",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if the installation disk should be wiped at installation time.\nDefaults to `true`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if the installation disk should be wiped at installation time." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
			{
				Name:        "legacyBIOSSupport",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if MBR partition should be marked as bootable (active).\nShould be enabled only for the systems with legacy BIOS that doesn't support GPT partitioning scheme.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if MBR partition should be marked as bootable (active)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("MachineInstall config usage example.", machineInstallExample())

	doc.Fields[0].AddExample("", "/dev/sda")
	doc.Fields[0].AddExample("", "/dev/nvme0")
	doc.Fields[1].AddExample("", machineInstallDiskSelectorExample())
	doc.Fields[2].AddExample("", []string{"talos.platform=metal", "reboot=k"})
	doc.Fields[3].AddExample("", "ghcr.io/siderolabs/installer:latest")
	doc.Fields[4].AddExample("", installExtensionsExample())

	return doc
}

func (InstallDiskSelector) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "InstallDiskSelector",
		Comments:    [3]string{"" /* encoder.HeadComment */, "InstallDiskSelector represents a disk query parameters for the install disk lookup." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "InstallDiskSelector represents a disk query parameters for the install disk lookup.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "InstallConfig",
				FieldName: "diskSelector",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "size",
				Type:        "InstallDiskSizeMatcher",
				Note:        "",
				Description: "Disk size.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk size." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Disk name `/sys/block/<dev>/device/name`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk name `/sys/block/<dev>/device/name`." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "model",
				Type:        "string",
				Note:        "",
				Description: "Disk model `/sys/block/<dev>/device/model`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk model `/sys/block/<dev>/device/model`." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "serial",
				Type:        "string",
				Note:        "",
				Description: "Disk serial number `/sys/block/<dev>/serial`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk serial number `/sys/block/<dev>/serial`." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "modalias",
				Type:        "string",
				Note:        "",
				Description: "Disk modalias `/sys/block/<dev>/device/modalias`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk modalias `/sys/block/<dev>/device/modalias`." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "uuid",
				Type:        "string",
				Note:        "",
				Description: "Disk UUID `/sys/block/<dev>/uuid`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk UUID `/sys/block/<dev>/uuid`." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "wwid",
				Type:        "string",
				Note:        "",
				Description: "Disk WWID `/sys/block/<dev>/wwid`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk WWID `/sys/block/<dev>/wwid`." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "type",
				Type:        "InstallDiskType",
				Note:        "",
				Description: "Disk Type.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk Type." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"ssd",
					"hdd",
					"nvme",
					"sd",
				},
			},
			{
				Name:        "busPath",
				Type:        "string",
				Note:        "",
				Description: "Disk bus path.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disk bus path." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineInstallDiskSelectorExample())

	doc.Fields[0].AddExample("Select a disk which size is equal to 4GB.", machineInstallDiskSizeMatcherExamples0())
	doc.Fields[0].AddExample("Select a disk which size is greater than 1TB.", machineInstallDiskSizeMatcherExamples1())
	doc.Fields[0].AddExample("Select a disk which size is less or equal than 2TB.", machineInstallDiskSizeMatcherExamples2())
	doc.Fields[8].AddExample("", "/pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0")
	doc.Fields[8].AddExample("", "/pci0000:00/*")

	return doc
}

func (InstallExtensionConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "InstallExtensionConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "InstallExtensionConfig represents a configuration for a system extension." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "InstallExtensionConfig represents a configuration for a system extension.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "InstallConfig",
				FieldName: "extensions",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "System extension image.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "System extension image." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", installExtensionsExample())

	return doc
}

func (TimeConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "TimeConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "TimeConfig represents the options for configuring time on a machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "TimeConfig represents the options for configuring time on a machine.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "time",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if the time service is disabled for the machine.\nDefaults to `false`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if the time service is disabled for the machine." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "servers",
				Type:        "[]string",
				Note:        "",
				Description: "description: |\n    Specifies time (NTP) servers to use for setting the system time.\n    Defaults to `time.cloudflare.com`.\n\n   Talos can also sync to the PTP time source (e.g provided by the hypervisor),\n    provide the path to the PTP device as \"/dev/ptp0\" or \"/dev/ptp_kvm\".\n",
				Comments:    [3]string{"" /* encoder.HeadComment */, "description: |" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "bootTimeout",
				Type:        "Duration",
				Note:        "",
				Description: "Specifies the timeout when the node time is considered to be in sync unlocking the boot sequence.\nNTP sync will be still running in the background.\nDefaults to \"infinity\" (waiting forever for time sync)",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the timeout when the node time is considered to be in sync unlocking the boot sequence." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("Example configuration for cloudflare ntp server.", machineTimeExample())

	return doc
}

func (RegistriesConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistriesConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistriesConfig represents the image pull options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistriesConfig represents the image pull options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "registries",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "mirrors",
				Type:        "map[string]RegistryMirrorConfig",
				Note:        "",
				Description: "Specifies mirror configuration for each registry host namespace.\nThis setting allows to configure local pull-through caching registires,\nair-gapped installations, etc.\n\nFor example, when pulling an image with the reference `example.com:123/image:v1`,\nthe `example.com:123` key will be used to lookup the mirror configuration.\n\nOptionally the `*` key can be used to configure a fallback mirror.\n\nRegistry name is the first segment of image identifier, with 'docker.io'\nbeing default one.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies mirror configuration for each registry host namespace." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "config",
				Type:        "map[string]RegistryConfig",
				Note:        "",
				Description: "Specifies TLS & auth configuration for HTTPS image registries.\nMutual TLS can be enabled with 'clientIdentity' option.\n\nThe full hostname and port (if not using a default port 443)\nshould be used as the key.\nThe fallback key `*` can't be used for TLS configuration.\n\nTLS configuration can be skipped if registry has trusted\nserver certificate.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies TLS & auth configuration for HTTPS image registries." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineConfigRegistriesExample())

	doc.Fields[0].AddExample("", machineConfigRegistryMirrorsExample())
	doc.Fields[1].AddExample("", machineConfigRegistryConfigExample())

	return doc
}

func (CoreDNS) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "CoreDNS",
		Comments:    [3]string{"" /* encoder.HeadComment */, "CoreDNS represents the CoreDNS config values." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "CoreDNS represents the CoreDNS config values.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "coreDNS",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Disable coredns deployment on cluster bootstrap.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable coredns deployment on cluster bootstrap." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The `image` field is an override to the default coredns image.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `image` field is an override to the default coredns image." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterCoreDNSExample())

	return doc
}

func (Endpoint) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Endpoint",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Endpoint represents the endpoint URL parsed out of the machine config." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Endpoint represents the endpoint URL parsed out of the machine config.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ControlPlaneConfig",
				FieldName: "endpoint",
			},
			{
				TypeName:  "LoggingDestination",
				FieldName: "endpoint",
			},
		},
		Fields: []encoder.Doc{
			{},
		},
	}

	doc.AddExample("", clusterEndpointExample1())

	doc.AddExample("", clusterEndpointExample2())

	doc.AddExample("", loggingEndpointExample1())

	doc.AddExample("", loggingEndpointExample2())

	return doc
}

func (ControlPlaneConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ControlPlaneConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ControlPlaneConfig represents the control plane configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ControlPlaneConfig represents the control plane configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "controlPlane",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "endpoint",
				Type:        "Endpoint",
				Note:        "",
				Description: "Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.\nIt is single-valued, and may optionally include a port number.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "localAPIServerPort",
				Type:        "int",
				Note:        "",
				Description: "The port that the API server listens on internally.\nThis may be different than the port portion listed in the endpoint field above.\nThe default is `6443`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The port that the API server listens on internally." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("Setting controlplane endpoint address to 1.2.3.4 and port to 443 example.", clusterControlPlaneExample())

	doc.Fields[0].AddExample("", clusterEndpointExample1())
	doc.Fields[0].AddExample("", clusterEndpointExample2())

	return doc
}

func (APIServerConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "APIServerConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "APIServerConfig represents the kube apiserver configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "APIServerConfig represents the kube apiserver configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "apiServer",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The container image used in the API server manifest.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The container image used in the API server manifest." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraArgs",
				Type:        "map[string]string",
				Note:        "",
				Description: "Extra arguments to supply to the API server.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra arguments to supply to the API server." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraVolumes",
				Type:        "[]VolumeMountConfig",
				Note:        "",
				Description: "Extra volumes to mount to the API server static pod.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra volumes to mount to the API server static pod." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "env",
				Type:        "Env",
				Note:        "",
				Description: "The `env` field allows for the addition of environment variables for the control plane component.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `env` field allows for the addition of environment variables for the control plane component." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "certSANs",
				Type:        "[]string",
				Note:        "",
				Description: "Extra certificate subject alternative names for the API server's certificate.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra certificate subject alternative names for the API server's certificate." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "disablePodSecurityPolicy",
				Type:        "bool",
				Note:        "",
				Description: "Disable PodSecurityPolicy in the API server and default manifests.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable PodSecurityPolicy in the API server and default manifests." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "admissionControl",
				Type:        "[]AdmissionPluginConfig",
				Note:        "",
				Description: "Configure the API server admission plugins.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure the API server admission plugins." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "auditPolicy",
				Type:        "Unstructured",
				Note:        "",
				Description: "Configure the API server audit policy.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure the API server audit policy." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "resources",
				Type:        "ResourcesConfig",
				Note:        "",
				Description: "Configure the API server resources.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure the API server resources." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterAPIServerExample())

	doc.Fields[0].AddExample("", clusterAPIServerImageExample())
	doc.Fields[6].AddExample("", admissionControlConfigExample())
	doc.Fields[7].AddExample("", APIServerDefaultAuditPolicy)

	return doc
}

func (AdmissionPluginConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "AdmissionPluginConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "AdmissionPluginConfig represents the API server admission plugin configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "AdmissionPluginConfig represents the API server admission plugin configuration.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "APIServerConfig",
				FieldName: "admissionControl",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Name is the name of the admission controller.\nIt must match the registered admission plugin name.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Name is the name of the admission controller." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "configuration",
				Type:        "Unstructured",
				Note:        "",
				Description: "Configuration is an embedded configuration object to be used as the plugin's\nconfiguration.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configuration is an embedded configuration object to be used as the plugin's" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", admissionControlConfigExample())

	return doc
}

func (ControllerManagerConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ControllerManagerConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ControllerManagerConfig represents the kube controller manager configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ControllerManagerConfig represents the kube controller manager configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "controllerManager",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The container image used in the controller manager manifest.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The container image used in the controller manager manifest." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraArgs",
				Type:        "map[string]string",
				Note:        "",
				Description: "Extra arguments to supply to the controller manager.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra arguments to supply to the controller manager." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraVolumes",
				Type:        "[]VolumeMountConfig",
				Note:        "",
				Description: "Extra volumes to mount to the controller manager static pod.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra volumes to mount to the controller manager static pod." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "env",
				Type:        "Env",
				Note:        "",
				Description: "The `env` field allows for the addition of environment variables for the control plane component.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `env` field allows for the addition of environment variables for the control plane component." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "resources",
				Type:        "ResourcesConfig",
				Note:        "",
				Description: "Configure the controller manager resources.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure the controller manager resources." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterControllerManagerExample())

	doc.Fields[0].AddExample("", clusterControllerManagerImageExample())

	return doc
}

func (ProxyConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ProxyConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ProxyConfig represents the kube proxy configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ProxyConfig represents the kube proxy configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "proxy",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Disable kube-proxy deployment on cluster bootstrap.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable kube-proxy deployment on cluster bootstrap." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The container image used in the kube-proxy manifest.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The container image used in the kube-proxy manifest." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mode",
				Type:        "string",
				Note:        "",
				Description: "proxy mode of kube-proxy.\nThe default is 'iptables'.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "proxy mode of kube-proxy." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraArgs",
				Type:        "map[string]string",
				Note:        "",
				Description: "Extra arguments to supply to kube-proxy.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra arguments to supply to kube-proxy." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterProxyExample())

	doc.Fields[0].AddExample("", pointer.To(false))
	doc.Fields[1].AddExample("", clusterProxyImageExample())

	return doc
}

func (SchedulerConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "SchedulerConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "SchedulerConfig represents the kube scheduler configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "SchedulerConfig represents the kube scheduler configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "scheduler",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The container image used in the scheduler manifest.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The container image used in the scheduler manifest." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraArgs",
				Type:        "map[string]string",
				Note:        "",
				Description: "Extra arguments to supply to the scheduler.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra arguments to supply to the scheduler." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraVolumes",
				Type:        "[]VolumeMountConfig",
				Note:        "",
				Description: "Extra volumes to mount to the scheduler static pod.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra volumes to mount to the scheduler static pod." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "env",
				Type:        "Env",
				Note:        "",
				Description: "The `env` field allows for the addition of environment variables for the control plane component.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `env` field allows for the addition of environment variables for the control plane component." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "resources",
				Type:        "ResourcesConfig",
				Note:        "",
				Description: "Configure the scheduler resources.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure the scheduler resources." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "config",
				Type:        "Unstructured",
				Note:        "",
				Description: "Specify custom kube-scheduler configuration.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specify custom kube-scheduler configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterSchedulerExample())

	doc.Fields[0].AddExample("", clusterSchedulerImageExample())

	return doc
}

func (EtcdConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EtcdConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EtcdConfig represents the etcd configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EtcdConfig represents the etcd configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "etcd",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "image",
				Type:        "string",
				Note:        "",
				Description: "The container image used to create the etcd service.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The container image used to create the etcd service." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ca",
				Type:        "PEMEncodedCertificateAndKey",
				Note:        "",
				Description: "The `ca` is the root certificate authority of the PKI.\nIt is composed of a base64 encoded `crt` and `key`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `ca` is the root certificate authority of the PKI." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "extraArgs",
				Type:        "map[string]string",
				Note:        "",
				Description: "Extra arguments to supply to etcd.\nNote that the following args are not allowed:\n\n- `name`\n- `data-dir`\n- `initial-cluster-state`\n- `listen-peer-urls`\n- `listen-client-urls`\n- `cert-file`\n- `key-file`\n- `trusted-ca-file`\n- `peer-client-cert-auth`\n- `peer-cert-file`\n- `peer-trusted-ca-file`\n- `peer-key-file`",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra arguments to supply to etcd." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{},
			{
				Name:        "advertisedSubnets",
				Type:        "[]string",
				Note:        "",
				Description: "The `advertisedSubnets` field configures the networks to pick etcd advertised IP from.\n\nIPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.\nNegative subnet matches should be specified last to filter out IPs picked by positive matches.\nIf not specified, advertised IP is selected as the first routable address of the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `advertisedSubnets` field configures the networks to pick etcd advertised IP from." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "listenSubnets",
				Type:        "[]string",
				Note:        "",
				Description: "The `listenSubnets` field configures the networks for the etcd to listen for peer and client connections.\n\nIf `listenSubnets` is not set, but `advertisedSubnets` is set, `listenSubnets` defaults to\n`advertisedSubnets`.\n\nIf neither `advertisedSubnets` nor `listenSubnets` is set, `listenSubnets` defaults to listen on all addresses.\n\nIPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.\nNegative subnet matches should be specified last to filter out IPs picked by positive matches.\nIf not specified, advertised IP is selected as the first routable address of the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The `listenSubnets` field configures the networks for the etcd to listen for peer and client connections." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterEtcdExample())

	doc.Fields[0].AddExample("", clusterEtcdImageExample())
	doc.Fields[1].AddExample("", pemEncodedCertificateExample())
	doc.Fields[4].AddExample("", clusterEtcdAdvertisedSubnetsExample())

	return doc
}

func (ClusterNetworkConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ClusterNetworkConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ClusterNetworkConfig represents kube networking configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ClusterNetworkConfig represents kube networking configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "network",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "cni",
				Type:        "CNIConfig",
				Note:        "",
				Description: "The CNI used.\nComposed of \"name\" and \"urls\".\nThe \"name\" key supports the following options: \"flannel\", \"custom\", and \"none\".\n\"flannel\" uses Talos-managed Flannel CNI, and that's the default option.\n\"custom\" uses custom manifests that should be provided in \"urls\".\n\"none\" indicates that Talos will not manage any CNI installation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The CNI used." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "dnsDomain",
				Type:        "string",
				Note:        "",
				Description: "The domain used by Kubernetes DNS.\nThe default is `cluster.local`",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The domain used by Kubernetes DNS." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "podSubnets",
				Type:        "[]string",
				Note:        "",
				Description: "The pod subnet CIDR.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The pod subnet CIDR." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "serviceSubnets",
				Type:        "[]string",
				Note:        "",
				Description: "The service subnet CIDR.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The service subnet CIDR." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("Configuring with flannel CNI and setting up subnets.", clusterNetworkExample())

	doc.Fields[0].AddExample("", clusterCustomCNIExample())
	doc.Fields[1].AddExample("", "cluser.local")
	doc.Fields[2].AddExample("", []string{"10.244.0.0/16"})
	doc.Fields[3].AddExample("", []string{"10.96.0.0/12"})

	return doc
}

func (CNIConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "CNIConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "CNIConfig represents the CNI configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "CNIConfig represents the CNI configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterNetworkConfig",
				FieldName: "cni",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Name of CNI to use.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Name of CNI to use." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"flannel",
					"custom",
					"none",
				},
			},
			{
				Name:        "urls",
				Type:        "[]string",
				Note:        "",
				Description: "URLs containing manifests to apply for the CNI.\nShould be present for \"custom\", must be empty for \"flannel\" and \"none\".",
				Comments:    [3]string{"" /* encoder.HeadComment */, "URLs containing manifests to apply for the CNI." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "flannel",
				Type:        "FlannelCNIConfig",
				Note:        "",
				Description: "description: |\nFlannel configuration options.\n",
				Comments:    [3]string{"" /* encoder.HeadComment */, "description: |" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterCustomCNIExample())

	return doc
}

func (FlannelCNIConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "FlannelCNIConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "FlannelCNIConfig represents the Flannel CNI configuration options." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "FlannelCNIConfig represents the Flannel CNI configuration options.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "CNIConfig",
				FieldName: "flannel",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "extraArgs",
				Type:        "[]string",
				Note:        "",
				Description: "Extra arguments for 'flanneld'.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra arguments for 'flanneld'." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("", []string{"--iface-can-reach=192.168.1.1"})

	return doc
}

func (ExternalCloudProviderConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ExternalCloudProviderConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ExternalCloudProviderConfig contains external cloud provider configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ExternalCloudProviderConfig contains external cloud provider configuration.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "externalCloudProvider",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable external cloud provider.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable external cloud provider." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"true",
					"yes",
					"false",
					"no",
				},
			},
			{
				Name:        "manifests",
				Type:        "[]string",
				Note:        "",
				Description: "A list of urls that point to additional manifests for an external cloud provider.\nThese will get automatically deployed as part of the bootstrap.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A list of urls that point to additional manifests for an external cloud provider." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterExternalCloudProviderConfigExample())

	doc.Fields[1].AddExample("", []string{
		"https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/rbac.yaml",
		"https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/aws-cloud-controller-manager-daemonset.yaml",
	})

	return doc
}

func (AdminKubeconfigConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "AdminKubeconfigConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "AdminKubeconfigConfig contains admin kubeconfig settings." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "AdminKubeconfigConfig contains admin kubeconfig settings.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "adminKubeconfig",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "certLifetime",
				Type:        "Duration",
				Note:        "",
				Description: "Admin kubeconfig certificate lifetime (default is 1 year).\nField format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Admin kubeconfig certificate lifetime (default is 1 year)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterAdminKubeconfigExample())

	return doc
}

func (MachineDisk) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineDisk",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineDisk represents the options available for partitioning, formatting, and" /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineDisk represents the options available for partitioning, formatting, and\nmounting extra disks.\n",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "disks",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "device",
				Type:        "string",
				Note:        "",
				Description: "The name of the disk to use.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The name of the disk to use." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "partitions",
				Type:        "[]DiskPartition",
				Note:        "",
				Description: "A list of partitions to create on the disk.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A list of partitions to create on the disk." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("MachineDisks list example.", machineDisksExample())

	return doc
}

func (DiskPartition) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DiskPartition",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DiskPartition represents the options for a disk partition." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DiskPartition represents the options for a disk partition.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineDisk",
				FieldName: "partitions",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "size",
				Type:        "DiskSize",
				Note:        "",
				Description: "The size of partition: either bytes or human readable representation. If `size:` is omitted, the partition is sized to occupy the full disk.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The size of partition: either bytes or human readable representation. If `size:` is omitted, the partition is sized to occupy the full disk." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mountpoint",
				Type:        "string",
				Note:        "",
				Description: "Where to mount the partition.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Where to mount the partition." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("Human readable representation.", DiskSize(100000000))
	doc.Fields[0].AddExample("Precise value in bytes.", 1024*1024*1024)

	return doc
}

func (EncryptionConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionConfig represents partition encryption settings." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionConfig represents partition encryption settings.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "SystemDiskEncryptionConfig",
				FieldName: "state",
			},
			{
				TypeName:  "SystemDiskEncryptionConfig",
				FieldName: "ephemeral",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "provider",
				Type:        "string",
				Note:        "",
				Description: "Encryption provider to use for the encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Encryption provider to use for the encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "keys",
				Type:        "[]EncryptionKey",
				Note:        "",
				Description: "Defines the encryption keys generation and storage method.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the encryption keys generation and storage method." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "cipher",
				Type:        "string",
				Note:        "",
				Description: "Cipher kind to use for the encryption. Depends on the encryption provider.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Cipher kind to use for the encryption. Depends on the encryption provider." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"aes-xts-plain64",
					"xchacha12,aes-adiantum-plain64",
					"xchacha20,aes-adiantum-plain64",
				},
			},
			{
				Name:        "keySize",
				Type:        "uint",
				Note:        "",
				Description: "Defines the encryption key length.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the encryption key length." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "blockSize",
				Type:        "uint64",
				Note:        "",
				Description: "Defines the encryption sector size.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the encryption sector size." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "options",
				Type:        "[]string",
				Note:        "",
				Description: "Additional --perf parameters for the LUKS2 encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Additional --perf parameters for the LUKS2 encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"no_read_workqueue",
					"no_write_workqueue",
					"same_cpu_crypt",
				},
			},
		},
	}

	doc.Fields[0].AddExample("", "luks2")
	doc.Fields[2].AddExample("", "aes-xts-plain64")
	doc.Fields[4].AddExample("", 4096)
	doc.Fields[5].AddExample("", []string{"no_read_workqueue", "no_write_workqueue"})

	return doc
}

func (EncryptionKey) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKey",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKey represents configuration for disk encryption key." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKey represents configuration for disk encryption key.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionConfig",
				FieldName: "keys",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "static",
				Type:        "EncryptionKeyStatic",
				Note:        "",
				Description: "Key which value is stored in the configuration file.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Key which value is stored in the configuration file." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "nodeID",
				Type:        "EncryptionKeyNodeID",
				Note:        "",
				Description: "Deterministically generated key from the node UUID and PartitionLabel.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Deterministically generated key from the node UUID and PartitionLabel." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kms",
				Type:        "EncryptionKeyKMS",
				Note:        "",
				Description: "KMS managed encryption key.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KMS managed encryption key." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "slot",
				Type:        "int",
				Note:        "",
				Description: "Key slot number for LUKS2 encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Key slot number for LUKS2 encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "tpm",
				Type:        "EncryptionKeyTPM",
				Note:        "",
				Description: "Enable TPM based disk encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable TPM based disk encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[2].AddExample("", kmsKeyExample())

	return doc
}

func (EncryptionKeyStatic) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyStatic",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyStatic represents throw away key type." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyStatic represents throw away key type.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "static",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "passphrase",
				Type:        "string",
				Note:        "",
				Description: "Defines the static passphrase value.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Defines the static passphrase value." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (EncryptionKeyKMS) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyKMS",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyKMS represents a key that is generated and then sealed/unsealed by the KMS server." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyKMS represents a key that is generated and then sealed/unsealed by the KMS server.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "kms",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "endpoint",
				Type:        "string",
				Note:        "",
				Description: "KMS endpoint to Seal/Unseal the key.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KMS endpoint to Seal/Unseal the key." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", kmsKeyExample())

	return doc
}

func (EncryptionKeyTPM) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyTPM",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyTPM represents a key that is generated and then sealed/unsealed by the TPM." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyTPM represents a key that is generated and then sealed/unsealed by the TPM.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "tpm",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "checkSecurebootStatusOnEnroll",
				Type:        "bool",
				Note:        "",
				Description: "Check that Secureboot is enabled in the EFI firmware.\nIf Secureboot is not enabled, the enrollment of the key will fail. As the TPM key is anyways bound to the value of PCR 7, changing Secureboot status or configuration after the initial enrollment will make the key unusable.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Check that Secureboot is enabled in the EFI firmware." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (EncryptionKeyNodeID) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "EncryptionKeyNodeID",
		Comments:    [3]string{"" /* encoder.HeadComment */, "EncryptionKeyNodeID represents deterministically generated key from the node UUID and PartitionLabel." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "EncryptionKeyNodeID represents deterministically generated key from the node UUID and PartitionLabel.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "EncryptionKey",
				FieldName: "nodeID",
			},
		},
		Fields: []encoder.Doc{},
	}

	return doc
}

func (ResourcesConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ResourcesConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ResourcesConfig represents the pod resources." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ResourcesConfig represents the pod resources.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "APIServerConfig",
				FieldName: "resources",
			},
			{
				TypeName:  "ControllerManagerConfig",
				FieldName: "resources",
			},
			{
				TypeName:  "SchedulerConfig",
				FieldName: "resources",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "requests",
				Type:        "Unstructured",
				Note:        "",
				Description: "Requests configures the reserved cpu/memory resources.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Requests configures the reserved cpu/memory resources." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "limits",
				Type:        "Unstructured",
				Note:        "",
				Description: "Limits configures the maximum cpu/memory resources a container can use.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Limits configures the maximum cpu/memory resources a container can use." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("resources requests.", resourcesConfigRequestsExample())
	doc.Fields[1].AddExample("resources requests.", resourcesConfigLimitsExample())

	return doc
}

func (MachineFile) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "MachineFile",
		Comments:    [3]string{"" /* encoder.HeadComment */, "MachineFile represents a file to write to disk." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "MachineFile represents a file to write to disk.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "files",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "content",
				Type:        "string",
				Note:        "",
				Description: "The contents of the file.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The contents of the file." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "permissions",
				Type:        "FileMode",
				Note:        "",
				Description: "The file's permissions in octal.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The file's permissions in octal." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "path",
				Type:        "string",
				Note:        "",
				Description: "The path of the file.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The path of the file." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "op",
				Type:        "string",
				Note:        "",
				Description: "The operation to use",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The operation to use" /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"create",
					"append",
					"overwrite",
				},
			},
		},
	}

	doc.AddExample("MachineFiles usage example.", machineFilesExample())

	return doc
}

func (ExtraHost) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ExtraHost",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ExtraHost represents a host entry in /etc/hosts." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ExtraHost represents a host entry in /etc/hosts.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "NetworkConfig",
				FieldName: "extraHostEntries",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "ip",
				Type:        "string",
				Note:        "",
				Description: "The IP of the host.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The IP of the host." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "aliases",
				Type:        "[]string",
				Note:        "",
				Description: "The host alias.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The host alias." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkConfigExtraHostsExample())

	return doc
}

func (Device) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Device",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Device represents a network interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Device represents a network interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "NetworkConfig",
				FieldName: "interfaces",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "interface",
				Type:        "string",
				Note:        "",
				Description: "The interface name.\nMutually exclusive with `deviceSelector`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The interface name." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "deviceSelector",
				Type:        "NetworkDeviceSelector",
				Note:        "",
				Description: "Picks a network device using the selector.\nMutually exclusive with `interface`.\nSupports partial match using wildcard syntax.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Picks a network device using the selector." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "addresses",
				Type:        "[]string",
				Note:        "",
				Description: "Assigns static IP addresses to the interface.\nAn address can be specified either in proper CIDR notation or as a standalone address (netmask of all ones is assumed).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Assigns static IP addresses to the interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{},
			{
				Name:        "routes",
				Type:        "[]Route",
				Note:        "",
				Description: "A list of routes associated with the interface.\nIf used in combination with DHCP, these routes will be appended to routes returned by DHCP server.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A list of routes associated with the interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "bond",
				Type:        "Bond",
				Note:        "",
				Description: "Bond specific options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Bond specific options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "bridge",
				Type:        "Bridge",
				Note:        "",
				Description: "Bridge specific options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Bridge specific options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "bridgePort",
				Type:        "BridgePort",
				Note:        "",
				Description: "Configure this device as a bridge port.\nThis can be used to dynamically assign network interfaces to a bridge.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure this device as a bridge port." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "vlans",
				Type:        "[]Vlan",
				Note:        "",
				Description: "VLAN specific options.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "VLAN specific options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mtu",
				Type:        "int",
				Note:        "",
				Description: "The interface's MTU.\nIf used in combination with DHCP, this will override any MTU settings returned from DHCP server.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The interface's MTU." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "dhcp",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if DHCP should be used to configure the interface.\nThe following DHCP options are supported:\n\n- `OptionClasslessStaticRoute`\n- `OptionDomainNameServer`\n- `OptionDNSDomainSearchList`\n- `OptionHostName`",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if DHCP should be used to configure the interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ignore",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if the interface should be ignored (skips configuration).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if the interface should be ignored (skips configuration)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "dummy",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if the interface is a dummy interface.\n`dummy` is used to specify that this interface should be a virtual-only, dummy interface.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if the interface is a dummy interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "dhcpOptions",
				Type:        "DHCPOptions",
				Note:        "",
				Description: "DHCP specific options.\n`dhcp` *must* be set to true for these to take effect.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "DHCP specific options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "wireguard",
				Type:        "DeviceWireguardConfig",
				Note:        "",
				Description: "Wireguard specific configuration.\nIncludes things like private key, listen port, peers.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Wireguard specific configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "vip",
				Type:        "DeviceVIPConfig",
				Note:        "",
				Description: "Virtual (shared) IP address configuration.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Virtual (shared) IP address configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineNetworkConfigExample().NetworkInterfaces)

	doc.Fields[0].AddExample("", "enp0s3")
	doc.Fields[1].AddExample("select a device with bus prefix 00:*.", networkDeviceSelectorExamples()[0])
	doc.Fields[1].AddExample("select a device with mac address matching `*:f0:ab` and `virtio` kernel driver.", networkDeviceSelectorExamples()[1])
	doc.Fields[2].AddExample("", []string{"10.5.0.0/16", "192.168.3.7"})
	doc.Fields[4].AddExample("", networkConfigRoutesExample())
	doc.Fields[5].AddExample("", networkConfigBondExample())
	doc.Fields[6].AddExample("", networkConfigBridgeExample())
	doc.Fields[7].AddExample("", networkConfigDynamicBridgePortsExample())
	doc.Fields[10].AddExample("", true)
	doc.Fields[13].AddExample("", networkConfigDHCPOptionsExample())
	doc.Fields[14].AddExample("wireguard server example", networkConfigWireguardHostExample())
	doc.Fields[14].AddExample("wireguard peer example", networkConfigWireguardPeerExample())
	doc.Fields[15].AddExample("layer2 vip example", networkConfigVIPLayer2Example())

	return doc
}

func (DHCPOptions) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DHCPOptions",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DHCPOptions contains options for configuring the DHCP settings for a given interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DHCPOptions contains options for configuring the DHCP settings for a given interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "dhcpOptions",
			},
			{
				TypeName:  "Vlan",
				FieldName: "dhcpOptions",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "routeMetric",
				Type:        "uint32",
				Note:        "",
				Description: "The priority of all routes received via DHCP.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The priority of all routes received via DHCP." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ipv4",
				Type:        "bool",
				Note:        "",
				Description: "Enables DHCPv4 protocol for the interface (default is enabled).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enables DHCPv4 protocol for the interface (default is enabled)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ipv6",
				Type:        "bool",
				Note:        "",
				Description: "Enables DHCPv6 protocol for the interface (default is disabled).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enables DHCPv6 protocol for the interface (default is disabled)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "duidv6",
				Type:        "string",
				Note:        "",
				Description: "Set client DUID (hex string).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Set client DUID (hex string)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkConfigDHCPOptionsExample())

	return doc
}

func (DeviceWireguardConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DeviceWireguardConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DeviceWireguardConfig contains settings for configuring Wireguard network interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DeviceWireguardConfig contains settings for configuring Wireguard network interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "wireguard",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "privateKey",
				Type:        "string",
				Note:        "",
				Description: "Specifies a private key configuration (base64 encoded).\nCan be generated by `wg genkey`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies a private key configuration (base64 encoded)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "listenPort",
				Type:        "int",
				Note:        "",
				Description: "Specifies a device's listening port.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies a device's listening port." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "firewallMark",
				Type:        "int",
				Note:        "",
				Description: "Specifies a device's firewall mark.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies a device's firewall mark." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "peers",
				Type:        "[]DeviceWireguardPeer",
				Note:        "",
				Description: "Specifies a list of peer configurations to apply to a device.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies a list of peer configurations to apply to a device." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("wireguard server example", networkConfigWireguardHostExample())

	doc.AddExample("wireguard peer example", networkConfigWireguardPeerExample())

	return doc
}

func (DeviceWireguardPeer) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DeviceWireguardPeer",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DeviceWireguardPeer a WireGuard device peer configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DeviceWireguardPeer a WireGuard device peer configuration.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "DeviceWireguardConfig",
				FieldName: "peers",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "publicKey",
				Type:        "string",
				Note:        "",
				Description: "Specifies the public key of this peer.\nCan be extracted from private key by running `wg pubkey < private.key > public.key && cat public.key`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the public key of this peer." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "endpoint",
				Type:        "string",
				Note:        "",
				Description: "Specifies the endpoint of this peer entry.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the endpoint of this peer entry." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "persistentKeepaliveInterval",
				Type:        "Duration",
				Note:        "",
				Description: "Specifies the persistent keepalive interval for this peer.\nField format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the persistent keepalive interval for this peer." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "allowedIPs",
				Type:        "[]string",
				Note:        "",
				Description: "AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (DeviceVIPConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DeviceVIPConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DeviceVIPConfig contains settings for configuring a Virtual Shared IP on an interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DeviceVIPConfig contains settings for configuring a Virtual Shared IP on an interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "vip",
			},
			{
				TypeName:  "Vlan",
				FieldName: "vip",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "ip",
				Type:        "string",
				Note:        "",
				Description: "Specifies the IP address to be used.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the IP address to be used." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "equinixMetal",
				Type:        "VIPEquinixMetalConfig",
				Note:        "",
				Description: "Specifies the Equinix Metal API settings to assign VIP to the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the Equinix Metal API settings to assign VIP to the node." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "hcloud",
				Type:        "VIPHCloudConfig",
				Note:        "",
				Description: "Specifies the Hetzner Cloud API settings to assign VIP to the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the Hetzner Cloud API settings to assign VIP to the node." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("layer2 vip example", networkConfigVIPLayer2Example())

	return doc
}

func (VIPEquinixMetalConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "VIPEquinixMetalConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "VIPEquinixMetalConfig contains settings for Equinix Metal VIP management." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "VIPEquinixMetalConfig contains settings for Equinix Metal VIP management.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "DeviceVIPConfig",
				FieldName: "equinixMetal",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "apiToken",
				Type:        "string",
				Note:        "",
				Description: "Specifies the Equinix Metal API Token.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the Equinix Metal API Token." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (VIPHCloudConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "VIPHCloudConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "VIPHCloudConfig contains settings for Hetzner Cloud VIP management." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "VIPHCloudConfig contains settings for Hetzner Cloud VIP management.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "DeviceVIPConfig",
				FieldName: "hcloud",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "apiToken",
				Type:        "string",
				Note:        "",
				Description: "Specifies the Hetzner Cloud API Token.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Specifies the Hetzner Cloud API Token." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (Bond) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Bond",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Bond contains the various options for configuring a bonded interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Bond contains the various options for configuring a bonded interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "bond",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "interfaces",
				Type:        "[]string",
				Note:        "",
				Description: "The interfaces that make up the bond.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The interfaces that make up the bond." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "deviceSelectors",
				Type:        "[]NetworkDeviceSelector",
				Note:        "",
				Description: "Picks a network device using the selector.\nMutually exclusive with `interfaces`.\nSupports partial match using wildcard syntax.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Picks a network device using the selector." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "arpIPTarget",
				Type:        "[]string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.\nNot supported at the moment.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mode",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "xmitHashPolicy",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "lacpRate",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "adActorSystem",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.\nNot supported at the moment.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "arpValidate",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "arpAllTargets",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "primary",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "primaryReselect",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "failOverMac",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "adSelect",
				Type:        "string",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "miimon",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "updelay",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "downdelay",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "arpInterval",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "resendIgmp",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "minLinks",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "lpInterval",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "packetsPerSlave",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "numPeerNotif",
				Type:        "uint8",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "tlbDynamicLb",
				Type:        "uint8",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "allSlavesActive",
				Type:        "uint8",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "useCarrier",
				Type:        "bool",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "adActorSysPrio",
				Type:        "uint16",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "adUserPortKey",
				Type:        "uint16",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "peerNotifyDelay",
				Type:        "uint32",
				Note:        "",
				Description: "A bond option.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A bond option." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkConfigBondExample())

	doc.Fields[1].AddExample("select a device with bus prefix 00:*, a device with mac address matching `*:f0:ab` and `virtio` kernel driver.", networkDeviceSelectorExamples())

	return doc
}

func (STP) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "STP",
		Comments:    [3]string{"" /* encoder.HeadComment */, "STP contains the various options for configuring the STP properties of a bridge interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "STP contains the various options for configuring the STP properties of a bridge interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Bridge",
				FieldName: "stp",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Whether Spanning Tree Protocol (STP) is enabled.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Whether Spanning Tree Protocol (STP) is enabled." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (BridgeVLAN) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "BridgeVLAN",
		Comments:    [3]string{"" /* encoder.HeadComment */, "BridgeVLAN contains the various options for configuring the VLAN properties of a bridge interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "BridgeVLAN contains the various options for configuring the VLAN properties of a bridge interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Bridge",
				FieldName: "vlan",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "vlanFiltering",
				Type:        "bool",
				Note:        "",
				Description: "Whether VLAN filtering is enabled.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Whether VLAN filtering is enabled." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (Bridge) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Bridge",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Bridge contains the various options for configuring a bridge interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Bridge contains the various options for configuring a bridge interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "bridge",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "interfaces",
				Type:        "[]string",
				Note:        "",
				Description: "The interfaces that make up the bridge.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The interfaces that make up the bridge." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "stp",
				Type:        "STP",
				Note:        "",
				Description: "Enable STP on this bridge.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable STP on this bridge." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "vlan",
				Type:        "BridgeVLAN",
				Note:        "",
				Description: "Enable VLAN-awareness on this bridge.\nPlease see the official kernel documentation.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable VLAN-awareness on this bridge." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkConfigBridgeExample())

	return doc
}

func (BridgePort) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "BridgePort",
		Comments:    [3]string{"" /* encoder.HeadComment */, "BridgePort contains settings for assigning a link to a bridge interface." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "BridgePort contains settings for assigning a link to a bridge interface.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "bridgePort",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "master",
				Type:        "string",
				Note:        "",
				Description: "The name of the bridge master interface",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The name of the bridge master interface" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkConfigDynamicBridgePortsExample())

	return doc
}

func (Vlan) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Vlan",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Vlan represents vlan settings for a device." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Vlan represents vlan settings for a device.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "vlans",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "addresses",
				Type:        "[]string",
				Note:        "",
				Description: "The addresses in CIDR notation or as plain IPs to use.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The addresses in CIDR notation or as plain IPs to use." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{},
			{
				Name:        "routes",
				Type:        "[]Route",
				Note:        "",
				Description: "A list of routes associated with the VLAN.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "A list of routes associated with the VLAN." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "dhcp",
				Type:        "bool",
				Note:        "",
				Description: "Indicates if DHCP should be used.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Indicates if DHCP should be used." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "vlanId",
				Type:        "uint16",
				Note:        "",
				Description: "The VLAN's ID.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The VLAN's ID." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mtu",
				Type:        "uint32",
				Note:        "",
				Description: "The VLAN's MTU.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The VLAN's MTU." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "vip",
				Type:        "DeviceVIPConfig",
				Note:        "",
				Description: "The VLAN's virtual IP address configuration.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The VLAN's virtual IP address configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "dhcpOptions",
				Type:        "DHCPOptions",
				Note:        "",
				Description: "DHCP specific options.\n`dhcp` *must* be set to true for these to take effect.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "DHCP specific options." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (Route) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "Route",
		Comments:    [3]string{"" /* encoder.HeadComment */, "Route represents a network route." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "Route represents a network route.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "routes",
			},
			{
				TypeName:  "Vlan",
				FieldName: "routes",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "network",
				Type:        "string",
				Note:        "",
				Description: "The route's network (destination).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The route's network (destination)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "gateway",
				Type:        "string",
				Note:        "",
				Description: "The route's gateway (if empty, creates link scope route).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The route's gateway (if empty, creates link scope route)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "source",
				Type:        "string",
				Note:        "",
				Description: "The route's source address (optional).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The route's source address (optional)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "metric",
				Type:        "uint32",
				Note:        "",
				Description: "The optional metric for the route.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The optional metric for the route." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mtu",
				Type:        "uint32",
				Note:        "",
				Description: "The optional MTU for the route.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The optional MTU for the route." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkConfigRoutesExample())

	return doc
}

func (RegistryMirrorConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistryMirrorConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistryMirrorConfig represents mirror configuration for a registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistryMirrorConfig represents mirror configuration for a registry.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "RegistriesConfig",
				FieldName: "mirrors",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "endpoints",
				Type:        "[]string",
				Note:        "",
				Description: "List of endpoints (URLs) for registry mirrors to use.\nEndpoint configures HTTP/HTTPS access mode, host name,\nport and path (if path is not set, it defaults to `/v2`).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "List of endpoints (URLs) for registry mirrors to use." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "overridePath",
				Type:        "bool",
				Note:        "",
				Description: "Use the exact path specified for the endpoint (don't append /v2/).\nThis setting is often required for setting up multiple mirrors\non a single instance of a registry.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Use the exact path specified for the endpoint (don't append /v2/)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "skipFallback",
				Type:        "bool",
				Note:        "",
				Description: "Skip fallback to the upstream endpoint, for example the mirror configuration\nfor `docker.io` will not fallback to `registry-1.docker.io`.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Skip fallback to the upstream endpoint, for example the mirror configuration" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineConfigRegistryMirrorsExample())

	return doc
}

func (RegistryConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistryConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistryConfig specifies auth & TLS config per registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistryConfig specifies auth & TLS config per registry.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "RegistriesConfig",
				FieldName: "config",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "tls",
				Type:        "RegistryTLSConfig",
				Note:        "",
				Description: "The TLS configuration for the registry.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The TLS configuration for the registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "auth",
				Type:        "RegistryAuthConfig",
				Note:        "",
				Description: "The auth configuration for this registry.\nNote: changes to the registry auth will not be picked up by the CRI containerd plugin without a reboot.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The auth configuration for this registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineConfigRegistryConfigExample())

	doc.Fields[0].AddExample("", machineConfigRegistryTLSConfigExample1())
	doc.Fields[0].AddExample("", machineConfigRegistryTLSConfigExample2())
	doc.Fields[1].AddExample("", machineConfigRegistryAuthConfigExample())

	return doc
}

func (RegistryAuthConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistryAuthConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistryAuthConfig specifies authentication configuration for a registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistryAuthConfig specifies authentication configuration for a registry.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "RegistryConfig",
				FieldName: "auth",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "username",
				Type:        "string",
				Note:        "",
				Description: "Optional registry authentication.\nThe meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Optional registry authentication." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "password",
				Type:        "string",
				Note:        "",
				Description: "Optional registry authentication.\nThe meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Optional registry authentication." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "auth",
				Type:        "string",
				Note:        "",
				Description: "Optional registry authentication.\nThe meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Optional registry authentication." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "identityToken",
				Type:        "string",
				Note:        "",
				Description: "Optional registry authentication.\nThe meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Optional registry authentication." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineConfigRegistryAuthConfigExample())

	return doc
}

func (RegistryTLSConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistryTLSConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistryTLSConfig specifies TLS config for HTTPS registries." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistryTLSConfig specifies TLS config for HTTPS registries.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "RegistryConfig",
				FieldName: "tls",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "clientIdentity",
				Type:        "PEMEncodedCertificateAndKey",
				Note:        "",
				Description: "Enable mutual TLS authentication with the registry.\nClient certificate and key should be base64-encoded.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable mutual TLS authentication with the registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ca",
				Type:        "Base64Bytes",
				Note:        "",
				Description: "CA registry certificate to add the list of trusted certificates.\nCertificate should be base64-encoded.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "CA registry certificate to add the list of trusted certificates." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "insecureSkipVerify",
				Type:        "bool",
				Note:        "",
				Description: "Skip TLS server certificate verification (not recommended).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Skip TLS server certificate verification (not recommended)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineConfigRegistryTLSConfigExample1())

	doc.AddExample("", machineConfigRegistryTLSConfigExample2())

	doc.Fields[0].AddExample("", pemEncodedCertificateExample())

	return doc
}

func (SystemDiskEncryptionConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "SystemDiskEncryptionConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "SystemDiskEncryptionConfig specifies system disk partitions encryption settings." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "SystemDiskEncryptionConfig specifies system disk partitions encryption settings.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "systemDiskEncryption",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "state",
				Type:        "EncryptionConfig",
				Note:        "",
				Description: "State partition encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "State partition encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "ephemeral",
				Type:        "EncryptionConfig",
				Note:        "",
				Description: "Ephemeral partition encryption.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Ephemeral partition encryption." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineSystemDiskEncryptionExample())

	return doc
}

func (FeaturesConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "FeaturesConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "FeaturesConfig describes individual Talos features that can be switched on or off." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "FeaturesConfig describes individual Talos features that can be switched on or off.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "features",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "rbac",
				Type:        "bool",
				Note:        "",
				Description: "Enable role-based access control (RBAC).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable role-based access control (RBAC)." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "stableHostname",
				Type:        "bool",
				Note:        "",
				Description: "Enable stable default hostname.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable stable default hostname." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kubernetesTalosAPIAccess",
				Type:        "KubernetesTalosAPIAccessConfig",
				Note:        "",
				Description: "Configure Talos API access from Kubernetes pods.\n\nThis feature is disabled if the feature config is not specified.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure Talos API access from Kubernetes pods." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "apidCheckExtKeyUsage",
				Type:        "bool",
				Note:        "",
				Description: "Enable checks for extended key usage of client certificates in apid.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable checks for extended key usage of client certificates in apid." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "diskQuotaSupport",
				Type:        "bool",
				Note:        "",
				Description: "Enable XFS project quota support for EPHEMERAL partition and user disks.\nAlso enables kubelet tracking of ephemeral disk usage in the kubelet via quota.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable XFS project quota support for EPHEMERAL partition and user disks." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "kubePrism",
				Type:        "KubePrism",
				Note:        "",
				Description: "KubePrism - local proxy/load balancer on defined port that will distribute\nrequests to all API servers in the cluster.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KubePrism - local proxy/load balancer on defined port that will distribute" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "hostDNS",
				Type:        "HostDNSConfig",
				Note:        "",
				Description: "Configures host DNS caching resolver.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configures host DNS caching resolver." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "imageCache",
				Type:        "bool",
				Note:        "",
				Description: "Enable Image Cache feature.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable Image Cache feature." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineFeaturesExample())

	doc.Fields[2].AddExample("", kubernetesTalosAPIAccessConfigExample())

	return doc
}

func (KubePrism) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KubePrism",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KubePrism describes the configuration for the KubePrism load balancer." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KubePrism describes the configuration for the KubePrism load balancer.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "FeaturesConfig",
				FieldName: "kubePrism",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable KubePrism support - will start local load balancing proxy.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable KubePrism support - will start local load balancing proxy." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "port",
				Type:        "int",
				Note:        "",
				Description: "KubePrism port.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KubePrism port." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (KubernetesTalosAPIAccessConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KubernetesTalosAPIAccessConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KubernetesTalosAPIAccessConfig describes the configuration for the Talos API access from Kubernetes pods." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KubernetesTalosAPIAccessConfig describes the configuration for the Talos API access from Kubernetes pods.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "FeaturesConfig",
				FieldName: "kubernetesTalosAPIAccess",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable Talos API access from Kubernetes pods.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable Talos API access from Kubernetes pods." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "allowedRoles",
				Type:        "[]string",
				Note:        "",
				Description: "The list of Talos API roles which can be granted for access from Kubernetes pods.\n\nEmpty list means that no roles can be granted, so access is blocked.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The list of Talos API roles which can be granted for access from Kubernetes pods." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "allowedKubernetesNamespaces",
				Type:        "[]string",
				Note:        "",
				Description: "The list of Kubernetes namespaces Talos API access is available from.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "The list of Kubernetes namespaces Talos API access is available from." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", kubernetesTalosAPIAccessConfigExample())

	return doc
}

func (HostDNSConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "HostDNSConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "HostDNSConfig describes the configuration for the host DNS resolver." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "HostDNSConfig describes the configuration for the host DNS resolver.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "FeaturesConfig",
				FieldName: "hostDNS",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable host DNS caching resolver.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable host DNS caching resolver." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "forwardKubeDNSToHost",
				Type:        "bool",
				Note:        "",
				Description: "Use the host DNS resolver as upstream for Kubernetes CoreDNS pods.\n\nWhen enabled, CoreDNS pods use host DNS server as the upstream DNS (instead of\nusing configured upstream DNS resolvers directly).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Use the host DNS resolver as upstream for Kubernetes CoreDNS pods." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "resolveMemberNames",
				Type:        "bool",
				Note:        "",
				Description: "Resolve member hostnames using the host DNS resolver.\n\nWhen enabled, cluster member hostnames and node names are resolved using the host DNS resolver.\nThis requires service discovery to be enabled.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Resolve member hostnames using the host DNS resolver." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (VolumeMountConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "VolumeMountConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "VolumeMountConfig struct describes extra volume mount for the static pods." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "VolumeMountConfig struct describes extra volume mount for the static pods.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "APIServerConfig",
				FieldName: "extraVolumes",
			},
			{
				TypeName:  "ControllerManagerConfig",
				FieldName: "extraVolumes",
			},
			{
				TypeName:  "SchedulerConfig",
				FieldName: "extraVolumes",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "hostPath",
				Type:        "string",
				Note:        "",
				Description: "Path on the host.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Path on the host." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mountPath",
				Type:        "string",
				Note:        "",
				Description: "Path in the container.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Path in the container." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "readonly",
				Type:        "bool",
				Note:        "",
				Description: "Mount the volume read only.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Mount the volume read only." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("", "/var/lib/auth")
	doc.Fields[1].AddExample("", "/etc/kubernetes/auth")
	doc.Fields[2].AddExample("", true)

	return doc
}

func (ClusterInlineManifest) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ClusterInlineManifest",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ClusterInlineManifest struct describes inline bootstrap manifests for the user." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ClusterInlineManifest struct describes inline bootstrap manifests for the user.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "inlineManifests",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Name of the manifest.\nName should be unique.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Name of the manifest." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "contents",
				Type:        "string",
				Note:        "",
				Description: "Manifest contents as a string.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Manifest contents as a string." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterInlineManifestsExample())

	doc.Fields[0].AddExample("", "csi")
	doc.Fields[1].AddExample("", "/etc/kubernetes/auth")

	return doc
}

func (NetworkKubeSpan) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "NetworkKubeSpan",
		Comments:    [3]string{"" /* encoder.HeadComment */, "NetworkKubeSpan struct describes KubeSpan configuration." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "NetworkKubeSpan struct describes KubeSpan configuration.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "NetworkConfig",
				FieldName: "kubespan",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable the KubeSpan feature.\nCluster discovery should be enabled with .cluster.discovery.enabled for KubeSpan to be enabled.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable the KubeSpan feature." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "advertiseKubernetesNetworks",
				Type:        "bool",
				Note:        "",
				Description: "Control whether Kubernetes pod CIDRs are announced over KubeSpan from the node.\nIf disabled, CNI handles encapsulating pod-to-pod traffic into some node-to-node tunnel,\nand KubeSpan handles the node-to-node traffic.\nIf enabled, KubeSpan will take over pod-to-pod traffic and send it over KubeSpan directly.\nWhen enabled, KubeSpan should have a way to detect complete pod CIDRs of the node which\nis not always the case with CNIs not relying on Kubernetes for IPAM.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Control whether Kubernetes pod CIDRs are announced over KubeSpan from the node." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "allowDownPeerBypass",
				Type:        "bool",
				Note:        "",
				Description: "Skip sending traffic via KubeSpan if the peer connection state is not up.\nThis provides configurable choice between connectivity and security: either traffic is always\nforced to go via KubeSpan (even if Wireguard peer connection is not up), or traffic can go directly\nto the peer if Wireguard connection can't be established.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Skip sending traffic via KubeSpan if the peer connection state is not up." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "harvestExtraEndpoints",
				Type:        "bool",
				Note:        "",
				Description: "KubeSpan can collect and publish extra endpoints for each member of the cluster\nbased on Wireguard endpoint information for each peer.\nThis feature is disabled by default, don't enable it\nwith high number of peers (>50) in the KubeSpan network (performance issues).",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KubeSpan can collect and publish extra endpoints for each member of the cluster" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "mtu",
				Type:        "uint32",
				Note:        "",
				Description: "KubeSpan link MTU size.\nDefault value is 1420.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KubeSpan link MTU size." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "filters",
				Type:        "KubeSpanFilters",
				Note:        "",
				Description: "KubeSpan advanced filtering of network addresses .\n\nSettings in this section are optional, and settings apply only to the node.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "KubeSpan advanced filtering of network addresses ." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", networkKubeSpanExample())

	return doc
}

func (KubeSpanFilters) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KubeSpanFilters",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KubeSpanFilters struct describes KubeSpan advanced network addresses filtering." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KubeSpanFilters struct describes KubeSpan advanced network addresses filtering.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "NetworkKubeSpan",
				FieldName: "filters",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "endpoints",
				Type:        "[]string",
				Note:        "",
				Description: "Filter node addresses which will be advertised as KubeSpan endpoints for peer-to-peer Wireguard connections.\n\nBy default, all addresses are advertised, and KubeSpan cycles through all endpoints until it finds one that works.\n\nDefault value: no filtering.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Filter node addresses which will be advertised as KubeSpan endpoints for peer-to-peer Wireguard connections." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("Exclude addresses in 192.168.0.0/16 subnet.", []string{"0.0.0.0/0", "!192.168.0.0/16", "::/0"})

	return doc
}

func (NetworkDeviceSelector) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "NetworkDeviceSelector",
		Comments:    [3]string{"" /* encoder.HeadComment */, "NetworkDeviceSelector struct describes network device selector." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "NetworkDeviceSelector struct describes network device selector.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "Device",
				FieldName: "deviceSelector",
			},
			{
				TypeName:  "Bond",
				FieldName: "deviceSelectors",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "busPath",
				Type:        "string",
				Note:        "",
				Description: "PCI, USB bus prefix, supports matching by wildcard.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "PCI, USB bus prefix, supports matching by wildcard." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "hardwareAddr",
				Type:        "string",
				Note:        "",
				Description: "Device hardware (MAC) address, supports matching by wildcard.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Device hardware (MAC) address, supports matching by wildcard." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "permanentAddr",
				Type:        "string",
				Note:        "",
				Description: "Device permanent hardware address, supports matching by wildcard.\nThe permanent address doesn't change when the link is enslaved to a bond,\nso it's recommended to use this field for bond members.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Device permanent hardware address, supports matching by wildcard." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "pciID",
				Type:        "string",
				Note:        "",
				Description: "PCI ID (vendor ID, product ID), supports matching by wildcard.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "PCI ID (vendor ID, product ID), supports matching by wildcard." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "driver",
				Type:        "string",
				Note:        "",
				Description: "Kernel driver, supports matching by wildcard.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Kernel driver, supports matching by wildcard." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "physical",
				Type:        "bool",
				Note:        "",
				Description: "Select only physical devices.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Select only physical devices." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("select a device with bus prefix 00:*.", networkDeviceSelectorExamples()[0])

	doc.AddExample("select a device with mac address matching `*:f0:ab` and `virtio` kernel driver.", networkDeviceSelectorExamples()[1])

	doc.AddExample("select a device with bus prefix 00:*, a device with mac address matching `*:f0:ab` and `virtio` kernel driver.", networkDeviceSelectorExamples())

	return doc
}

func (ClusterDiscoveryConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "ClusterDiscoveryConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "ClusterDiscoveryConfig struct configures cluster membership discovery." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "ClusterDiscoveryConfig struct configures cluster membership discovery.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterConfig",
				FieldName: "discovery",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "enabled",
				Type:        "bool",
				Note:        "",
				Description: "Enable the cluster membership discovery feature.\nCluster discovery is based on individual registries which are configured under the registries field.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Enable the cluster membership discovery feature." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "registries",
				Type:        "DiscoveryRegistriesConfig",
				Note:        "",
				Description: "Configure registries used for cluster member discovery.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Configure registries used for cluster member discovery." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", clusterDiscoveryExample())

	return doc
}

func (DiscoveryRegistriesConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "DiscoveryRegistriesConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "DiscoveryRegistriesConfig struct configures cluster membership discovery." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "DiscoveryRegistriesConfig struct configures cluster membership discovery.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "ClusterDiscoveryConfig",
				FieldName: "registries",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "kubernetes",
				Type:        "RegistryKubernetesConfig",
				Note:        "",
				Description: "Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information\nas annotations on the Node resources.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "service",
				Type:        "RegistryServiceConfig",
				Note:        "",
				Description: "Service registry is using an external service to push and pull information about cluster members.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Service registry is using an external service to push and pull information about cluster members." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (RegistryKubernetesConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistryKubernetesConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistryKubernetesConfig struct configures Kubernetes discovery registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistryKubernetesConfig struct configures Kubernetes discovery registry.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "DiscoveryRegistriesConfig",
				FieldName: "kubernetes",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Disable Kubernetes discovery registry.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable Kubernetes discovery registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

func (RegistryServiceConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "RegistryServiceConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "RegistryServiceConfig struct configures Kubernetes discovery registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "RegistryServiceConfig struct configures Kubernetes discovery registry.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "DiscoveryRegistriesConfig",
				FieldName: "service",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "disabled",
				Type:        "bool",
				Note:        "",
				Description: "Disable external service discovery registry.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Disable external service discovery registry." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "endpoint",
				Type:        "string",
				Note:        "",
				Description: "External service endpoint.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "External service endpoint." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[1].AddExample("", constants.DefaultDiscoveryServiceEndpoint)

	return doc
}

func (UdevConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "UdevConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "UdevConfig describes how the udev system should be configured." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "UdevConfig describes how the udev system should be configured.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "udev",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "rules",
				Type:        "[]string",
				Note:        "",
				Description: "List of udev rules to apply to the udev system",
				Comments:    [3]string{"" /* encoder.HeadComment */, "List of udev rules to apply to the udev system" /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineUdevExample())

	return doc
}

func (LoggingConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "LoggingConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "LoggingConfig struct configures Talos logging." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "LoggingConfig struct configures Talos logging.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "logging",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "destinations",
				Type:        "[]LoggingDestination",
				Note:        "",
				Description: "Logging destination.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Logging destination." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineLoggingExample())

	return doc
}

func (LoggingDestination) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "LoggingDestination",
		Comments:    [3]string{"" /* encoder.HeadComment */, "LoggingDestination struct configures Talos logging destination." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "LoggingDestination struct configures Talos logging destination.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "LoggingConfig",
				FieldName: "destinations",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "endpoint",
				Type:        "Endpoint",
				Note:        "",
				Description: "Where to send logs. Supported protocols are \"tcp\" and \"udp\".",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Where to send logs. Supported protocols are \"tcp\" and \"udp\"." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "format",
				Type:        "string",
				Note:        "",
				Description: "Logs format.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Logs format." /* encoder.LineComment */, "" /* encoder.FootComment */},
				Values: []string{
					"json_lines",
				},
			},
			{
				Name:        "extraTags",
				Type:        "map[string]string",
				Note:        "",
				Description: "Extra tags (key-value) pairs to attach to every log message sent.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Extra tags (key-value) pairs to attach to every log message sent." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.Fields[0].AddExample("", loggingEndpointExample1())
	doc.Fields[0].AddExample("", loggingEndpointExample2())

	return doc
}

func (KernelConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KernelConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KernelConfig struct configures Talos Linux kernel." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KernelConfig struct configures Talos Linux kernel.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "MachineConfig",
				FieldName: "kernel",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "modules",
				Type:        "[]KernelModuleConfig",
				Note:        "",
				Description: "Kernel modules to load.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Kernel modules to load." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	doc.AddExample("", machineKernelExample())

	return doc
}

func (KernelModuleConfig) Doc() *encoder.Doc {
	doc := &encoder.Doc{
		Type:        "KernelModuleConfig",
		Comments:    [3]string{"" /* encoder.HeadComment */, "KernelModuleConfig struct configures Linux kernel modules to load." /* encoder.LineComment */, "" /* encoder.FootComment */},
		Description: "KernelModuleConfig struct configures Linux kernel modules to load.",
		AppearsIn: []encoder.Appearance{
			{
				TypeName:  "KernelConfig",
				FieldName: "modules",
			},
		},
		Fields: []encoder.Doc{
			{
				Name:        "name",
				Type:        "string",
				Note:        "",
				Description: "Module name.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Module name." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
			{
				Name:        "parameters",
				Type:        "[]string",
				Note:        "",
				Description: "Module parameters, changes applied after reboot.",
				Comments:    [3]string{"" /* encoder.HeadComment */, "Module parameters, changes applied after reboot." /* encoder.LineComment */, "" /* encoder.FootComment */},
			},
		},
	}

	return doc
}

// GetFileDoc returns documentation for the file ./v1alpha1_types_doc.go.
func GetFileDoc() *encoder.FileDoc {
	return &encoder.FileDoc{
		Name:        "v1alpha1",
		Description: "Package v1alpha1 contains definition of the `v1alpha1` configuration document.\n\nEven though the machine configuration in Talos Linux is multi-document, at the moment\nthis configuration document contains most of the configuration options.\n\nIt is expected that new configuration options will be added as new documents, and existing ones\nmigrated to their own documents.\n",
		Structs: []*encoder.Doc{
			Config{}.Doc(),
			MachineConfig{}.Doc(),
			MachineSeccompProfile{}.Doc(),
			ClusterConfig{}.Doc(),
			LinuxIDMapping{}.Doc(),
			ExtraMount{}.Doc(),
			MachineControlPlaneConfig{}.Doc(),
			MachineControllerManagerConfig{}.Doc(),
			MachineSchedulerConfig{}.Doc(),
			KubeletConfig{}.Doc(),
			KubeletNodeIPConfig{}.Doc(),
			NetworkConfig{}.Doc(),
			InstallConfig{}.Doc(),
			InstallDiskSelector{}.Doc(),
			InstallExtensionConfig{}.Doc(),
			TimeConfig{}.Doc(),
			RegistriesConfig{}.Doc(),
			CoreDNS{}.Doc(),
			Endpoint{}.Doc(),
			ControlPlaneConfig{}.Doc(),
			APIServerConfig{}.Doc(),
			AdmissionPluginConfig{}.Doc(),
			ControllerManagerConfig{}.Doc(),
			ProxyConfig{}.Doc(),
			SchedulerConfig{}.Doc(),
			EtcdConfig{}.Doc(),
			ClusterNetworkConfig{}.Doc(),
			CNIConfig{}.Doc(),
			FlannelCNIConfig{}.Doc(),
			ExternalCloudProviderConfig{}.Doc(),
			AdminKubeconfigConfig{}.Doc(),
			MachineDisk{}.Doc(),
			DiskPartition{}.Doc(),
			EncryptionConfig{}.Doc(),
			EncryptionKey{}.Doc(),
			EncryptionKeyStatic{}.Doc(),
			EncryptionKeyKMS{}.Doc(),
			EncryptionKeyTPM{}.Doc(),
			EncryptionKeyNodeID{}.Doc(),
			ResourcesConfig{}.Doc(),
			MachineFile{}.Doc(),
			ExtraHost{}.Doc(),
			Device{}.Doc(),
			DHCPOptions{}.Doc(),
			DeviceWireguardConfig{}.Doc(),
			DeviceWireguardPeer{}.Doc(),
			DeviceVIPConfig{}.Doc(),
			VIPEquinixMetalConfig{}.Doc(),
			VIPHCloudConfig{}.Doc(),
			Bond{}.Doc(),
			STP{}.Doc(),
			BridgeVLAN{}.Doc(),
			Bridge{}.Doc(),
			BridgePort{}.Doc(),
			Vlan{}.Doc(),
			Route{}.Doc(),
			RegistryMirrorConfig{}.Doc(),
			RegistryConfig{}.Doc(),
			RegistryAuthConfig{}.Doc(),
			RegistryTLSConfig{}.Doc(),
			SystemDiskEncryptionConfig{}.Doc(),
			FeaturesConfig{}.Doc(),
			KubePrism{}.Doc(),
			KubernetesTalosAPIAccessConfig{}.Doc(),
			HostDNSConfig{}.Doc(),
			VolumeMountConfig{}.Doc(),
			ClusterInlineManifest{}.Doc(),
			NetworkKubeSpan{}.Doc(),
			KubeSpanFilters{}.Doc(),
			NetworkDeviceSelector{}.Doc(),
			ClusterDiscoveryConfig{}.Doc(),
			DiscoveryRegistriesConfig{}.Doc(),
			RegistryKubernetesConfig{}.Doc(),
			RegistryServiceConfig{}.Doc(),
			UdevConfig{}.Doc(),
			LoggingConfig{}.Doc(),
			LoggingDestination{}.Doc(),
			KernelConfig{}.Doc(),
			KernelModuleConfig{}.Doc(),
		},
	}
}

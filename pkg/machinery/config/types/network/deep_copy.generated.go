// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by "deep-copy -type BondConfigV1Alpha1 -type BridgeConfigV1Alpha1 -type DefaultActionConfigV1Alpha1 -type DHCPv4ConfigV1Alpha1 -type DHCPv6ConfigV1Alpha1 -type DummyLinkConfigV1Alpha1 -type EthernetConfigV1Alpha1 -type HCloudVIPConfigV1Alpha1 -type HostnameConfigV1Alpha1 -type KubeSpanConfigV1Alpha1 -type KubespanEndpointsConfigV1Alpha1 -type Layer2VIPConfigV1Alpha1 -type LinkConfigV1Alpha1 -type LinkAliasConfigV1Alpha1 -type ResolverConfigV1Alpha1 -type RuleConfigV1Alpha1 -type StaticHostConfigV1Alpha1 -type TCPProbeConfigV1Alpha1 -type TimeSyncConfigV1Alpha1 -type VLANConfigV1Alpha1 -type WireguardConfigV1Alpha1 -pointer-receiver -header-file ../../../../../hack/boilerplate.txt -o deep_copy.generated.go ."; DO NOT EDIT.

package network

import (
	"net/netip"

	"github.com/siderolabs/talos/pkg/machinery/nethelpers"
)

// DeepCopy generates a deep copy of *BondConfigV1Alpha1.
func (o *BondConfigV1Alpha1) DeepCopy() *BondConfigV1Alpha1 {
	var cp BondConfigV1Alpha1 = *o
	if o.HardwareAddressConfig != nil {
		cp.HardwareAddressConfig = make([]byte, len(o.HardwareAddressConfig))
		copy(cp.HardwareAddressConfig, o.HardwareAddressConfig)
	}
	if o.BondLinks != nil {
		cp.BondLinks = make([]string, len(o.BondLinks))
		copy(cp.BondLinks, o.BondLinks)
	}
	if o.BondMode != nil {
		cp.BondMode = new(nethelpers.BondMode)
		*cp.BondMode = *o.BondMode
	}
	if o.BondMIIMon != nil {
		cp.BondMIIMon = new(uint32)
		*cp.BondMIIMon = *o.BondMIIMon
	}
	if o.BondUpDelay != nil {
		cp.BondUpDelay = new(uint32)
		*cp.BondUpDelay = *o.BondUpDelay
	}
	if o.BondDownDelay != nil {
		cp.BondDownDelay = new(uint32)
		*cp.BondDownDelay = *o.BondDownDelay
	}
	if o.BondUseCarrier != nil {
		cp.BondUseCarrier = new(bool)
		*cp.BondUseCarrier = *o.BondUseCarrier
	}
	if o.BondXmitHashPolicy != nil {
		cp.BondXmitHashPolicy = new(nethelpers.BondXmitHashPolicy)
		*cp.BondXmitHashPolicy = *o.BondXmitHashPolicy
	}
	if o.BondARPInterval != nil {
		cp.BondARPInterval = new(uint32)
		*cp.BondARPInterval = *o.BondARPInterval
	}
	if o.BondARPIPTargets != nil {
		cp.BondARPIPTargets = make([]netip.Addr, len(o.BondARPIPTargets))
		copy(cp.BondARPIPTargets, o.BondARPIPTargets)
	}
	if o.BondNSIP6Targets != nil {
		cp.BondNSIP6Targets = make([]netip.Addr, len(o.BondNSIP6Targets))
		copy(cp.BondNSIP6Targets, o.BondNSIP6Targets)
	}
	if o.BondARPValidate != nil {
		cp.BondARPValidate = new(nethelpers.ARPValidate)
		*cp.BondARPValidate = *o.BondARPValidate
	}
	if o.BondARPAllTargets != nil {
		cp.BondARPAllTargets = new(nethelpers.ARPAllTargets)
		*cp.BondARPAllTargets = *o.BondARPAllTargets
	}
	if o.BondLACPRate != nil {
		cp.BondLACPRate = new(nethelpers.LACPRate)
		*cp.BondLACPRate = *o.BondLACPRate
	}
	if o.BondFailOverMAC != nil {
		cp.BondFailOverMAC = new(nethelpers.FailOverMAC)
		*cp.BondFailOverMAC = *o.BondFailOverMAC
	}
	if o.BondADSelect != nil {
		cp.BondADSelect = new(nethelpers.ADSelect)
		*cp.BondADSelect = *o.BondADSelect
	}
	if o.BondADActorSysPrio != nil {
		cp.BondADActorSysPrio = new(uint16)
		*cp.BondADActorSysPrio = *o.BondADActorSysPrio
	}
	if o.BondADUserPortKey != nil {
		cp.BondADUserPortKey = new(uint16)
		*cp.BondADUserPortKey = *o.BondADUserPortKey
	}
	if o.BondADLACPActive != nil {
		cp.BondADLACPActive = new(nethelpers.ADLACPActive)
		*cp.BondADLACPActive = *o.BondADLACPActive
	}
	if o.BondPrimaryReselect != nil {
		cp.BondPrimaryReselect = new(nethelpers.PrimaryReselect)
		*cp.BondPrimaryReselect = *o.BondPrimaryReselect
	}
	if o.BondResendIGMP != nil {
		cp.BondResendIGMP = new(uint32)
		*cp.BondResendIGMP = *o.BondResendIGMP
	}
	if o.BondMinLinks != nil {
		cp.BondMinLinks = new(uint32)
		*cp.BondMinLinks = *o.BondMinLinks
	}
	if o.BondLPInterval != nil {
		cp.BondLPInterval = new(uint32)
		*cp.BondLPInterval = *o.BondLPInterval
	}
	if o.BondPacketsPerSlave != nil {
		cp.BondPacketsPerSlave = new(uint32)
		*cp.BondPacketsPerSlave = *o.BondPacketsPerSlave
	}
	if o.BondNumPeerNotif != nil {
		cp.BondNumPeerNotif = new(uint8)
		*cp.BondNumPeerNotif = *o.BondNumPeerNotif
	}
	if o.BondTLBDynamicLB != nil {
		cp.BondTLBDynamicLB = new(uint8)
		*cp.BondTLBDynamicLB = *o.BondTLBDynamicLB
	}
	if o.BondAllSlavesActive != nil {
		cp.BondAllSlavesActive = new(uint8)
		*cp.BondAllSlavesActive = *o.BondAllSlavesActive
	}
	if o.BondPeerNotifyDelay != nil {
		cp.BondPeerNotifyDelay = new(uint32)
		*cp.BondPeerNotifyDelay = *o.BondPeerNotifyDelay
	}
	if o.BondMissedMax != nil {
		cp.BondMissedMax = new(uint8)
		*cp.BondMissedMax = *o.BondMissedMax
	}
	if o.CommonLinkConfig.LinkUp != nil {
		cp.CommonLinkConfig.LinkUp = new(bool)
		*cp.CommonLinkConfig.LinkUp = *o.CommonLinkConfig.LinkUp
	}
	if o.CommonLinkConfig.LinkAddresses != nil {
		cp.CommonLinkConfig.LinkAddresses = make([]AddressConfig, len(o.CommonLinkConfig.LinkAddresses))
		copy(cp.CommonLinkConfig.LinkAddresses, o.CommonLinkConfig.LinkAddresses)
		for i3 := range o.CommonLinkConfig.LinkAddresses {
			if o.CommonLinkConfig.LinkAddresses[i3].AddressPriority != nil {
				cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = new(uint32)
				*cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = *o.CommonLinkConfig.LinkAddresses[i3].AddressPriority
			}
		}
	}
	if o.CommonLinkConfig.LinkRoutes != nil {
		cp.CommonLinkConfig.LinkRoutes = make([]RouteConfig, len(o.CommonLinkConfig.LinkRoutes))
		copy(cp.CommonLinkConfig.LinkRoutes, o.CommonLinkConfig.LinkRoutes)
	}
	if o.CommonLinkConfig.LinkMulticast != nil {
		cp.CommonLinkConfig.LinkMulticast = new(bool)
		*cp.CommonLinkConfig.LinkMulticast = *o.CommonLinkConfig.LinkMulticast
	}
	return &cp
}

// DeepCopy generates a deep copy of *BridgeConfigV1Alpha1.
func (o *BridgeConfigV1Alpha1) DeepCopy() *BridgeConfigV1Alpha1 {
	var cp BridgeConfigV1Alpha1 = *o
	if o.HardwareAddressConfig != nil {
		cp.HardwareAddressConfig = make([]byte, len(o.HardwareAddressConfig))
		copy(cp.HardwareAddressConfig, o.HardwareAddressConfig)
	}
	if o.BridgeLinks != nil {
		cp.BridgeLinks = make([]string, len(o.BridgeLinks))
		copy(cp.BridgeLinks, o.BridgeLinks)
	}
	if o.BridgeSTP.BridgeSTPEnabled != nil {
		cp.BridgeSTP.BridgeSTPEnabled = new(bool)
		*cp.BridgeSTP.BridgeSTPEnabled = *o.BridgeSTP.BridgeSTPEnabled
	}
	if o.BridgeVLAN.BridgeVLANFiltering != nil {
		cp.BridgeVLAN.BridgeVLANFiltering = new(bool)
		*cp.BridgeVLAN.BridgeVLANFiltering = *o.BridgeVLAN.BridgeVLANFiltering
	}
	if o.CommonLinkConfig.LinkUp != nil {
		cp.CommonLinkConfig.LinkUp = new(bool)
		*cp.CommonLinkConfig.LinkUp = *o.CommonLinkConfig.LinkUp
	}
	if o.CommonLinkConfig.LinkAddresses != nil {
		cp.CommonLinkConfig.LinkAddresses = make([]AddressConfig, len(o.CommonLinkConfig.LinkAddresses))
		copy(cp.CommonLinkConfig.LinkAddresses, o.CommonLinkConfig.LinkAddresses)
		for i3 := range o.CommonLinkConfig.LinkAddresses {
			if o.CommonLinkConfig.LinkAddresses[i3].AddressPriority != nil {
				cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = new(uint32)
				*cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = *o.CommonLinkConfig.LinkAddresses[i3].AddressPriority
			}
		}
	}
	if o.CommonLinkConfig.LinkRoutes != nil {
		cp.CommonLinkConfig.LinkRoutes = make([]RouteConfig, len(o.CommonLinkConfig.LinkRoutes))
		copy(cp.CommonLinkConfig.LinkRoutes, o.CommonLinkConfig.LinkRoutes)
	}
	if o.CommonLinkConfig.LinkMulticast != nil {
		cp.CommonLinkConfig.LinkMulticast = new(bool)
		*cp.CommonLinkConfig.LinkMulticast = *o.CommonLinkConfig.LinkMulticast
	}
	return &cp
}

// DeepCopy generates a deep copy of *DefaultActionConfigV1Alpha1.
func (o *DefaultActionConfigV1Alpha1) DeepCopy() *DefaultActionConfigV1Alpha1 {
	var cp DefaultActionConfigV1Alpha1 = *o
	return &cp
}

// DeepCopy generates a deep copy of *DHCPv4ConfigV1Alpha1.
func (o *DHCPv4ConfigV1Alpha1) DeepCopy() *DHCPv4ConfigV1Alpha1 {
	var cp DHCPv4ConfigV1Alpha1 = *o
	if o.ConfigIgnoreHostname != nil {
		cp.ConfigIgnoreHostname = new(bool)
		*cp.ConfigIgnoreHostname = *o.ConfigIgnoreHostname
	}
	if o.ConfigClientIdentifier != nil {
		cp.ConfigClientIdentifier = new(nethelpers.ClientIdentifier)
		*cp.ConfigClientIdentifier = *o.ConfigClientIdentifier
	}
	if o.ConfigDUIDRaw != nil {
		cp.ConfigDUIDRaw = make([]byte, len(o.ConfigDUIDRaw))
		copy(cp.ConfigDUIDRaw, o.ConfigDUIDRaw)
	}
	return &cp
}

// DeepCopy generates a deep copy of *DHCPv6ConfigV1Alpha1.
func (o *DHCPv6ConfigV1Alpha1) DeepCopy() *DHCPv6ConfigV1Alpha1 {
	var cp DHCPv6ConfigV1Alpha1 = *o
	if o.ConfigIgnoreHostname != nil {
		cp.ConfigIgnoreHostname = new(bool)
		*cp.ConfigIgnoreHostname = *o.ConfigIgnoreHostname
	}
	if o.ConfigClientIdentifier != nil {
		cp.ConfigClientIdentifier = new(nethelpers.ClientIdentifier)
		*cp.ConfigClientIdentifier = *o.ConfigClientIdentifier
	}
	if o.ConfigDUIDRaw != nil {
		cp.ConfigDUIDRaw = make([]byte, len(o.ConfigDUIDRaw))
		copy(cp.ConfigDUIDRaw, o.ConfigDUIDRaw)
	}
	return &cp
}

// DeepCopy generates a deep copy of *DummyLinkConfigV1Alpha1.
func (o *DummyLinkConfigV1Alpha1) DeepCopy() *DummyLinkConfigV1Alpha1 {
	var cp DummyLinkConfigV1Alpha1 = *o
	if o.HardwareAddressConfig != nil {
		cp.HardwareAddressConfig = make([]byte, len(o.HardwareAddressConfig))
		copy(cp.HardwareAddressConfig, o.HardwareAddressConfig)
	}
	if o.CommonLinkConfig.LinkUp != nil {
		cp.CommonLinkConfig.LinkUp = new(bool)
		*cp.CommonLinkConfig.LinkUp = *o.CommonLinkConfig.LinkUp
	}
	if o.CommonLinkConfig.LinkAddresses != nil {
		cp.CommonLinkConfig.LinkAddresses = make([]AddressConfig, len(o.CommonLinkConfig.LinkAddresses))
		copy(cp.CommonLinkConfig.LinkAddresses, o.CommonLinkConfig.LinkAddresses)
		for i3 := range o.CommonLinkConfig.LinkAddresses {
			if o.CommonLinkConfig.LinkAddresses[i3].AddressPriority != nil {
				cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = new(uint32)
				*cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = *o.CommonLinkConfig.LinkAddresses[i3].AddressPriority
			}
		}
	}
	if o.CommonLinkConfig.LinkRoutes != nil {
		cp.CommonLinkConfig.LinkRoutes = make([]RouteConfig, len(o.CommonLinkConfig.LinkRoutes))
		copy(cp.CommonLinkConfig.LinkRoutes, o.CommonLinkConfig.LinkRoutes)
	}
	if o.CommonLinkConfig.LinkMulticast != nil {
		cp.CommonLinkConfig.LinkMulticast = new(bool)
		*cp.CommonLinkConfig.LinkMulticast = *o.CommonLinkConfig.LinkMulticast
	}
	return &cp
}

// DeepCopy generates a deep copy of *EthernetConfigV1Alpha1.
func (o *EthernetConfigV1Alpha1) DeepCopy() *EthernetConfigV1Alpha1 {
	var cp EthernetConfigV1Alpha1 = *o
	if o.FeaturesConfig != nil {
		cp.FeaturesConfig = make(map[string]bool, len(o.FeaturesConfig))
		for k2, v2 := range o.FeaturesConfig {
			cp.FeaturesConfig[k2] = v2
		}
	}
	if o.RingsConfig != nil {
		cp.RingsConfig = new(EthernetRingsConfig)
		*cp.RingsConfig = *o.RingsConfig
		if o.RingsConfig.RX != nil {
			cp.RingsConfig.RX = new(uint32)
			*cp.RingsConfig.RX = *o.RingsConfig.RX
		}
		if o.RingsConfig.TX != nil {
			cp.RingsConfig.TX = new(uint32)
			*cp.RingsConfig.TX = *o.RingsConfig.TX
		}
		if o.RingsConfig.RXMini != nil {
			cp.RingsConfig.RXMini = new(uint32)
			*cp.RingsConfig.RXMini = *o.RingsConfig.RXMini
		}
		if o.RingsConfig.RXJumbo != nil {
			cp.RingsConfig.RXJumbo = new(uint32)
			*cp.RingsConfig.RXJumbo = *o.RingsConfig.RXJumbo
		}
		if o.RingsConfig.RXBufLen != nil {
			cp.RingsConfig.RXBufLen = new(uint32)
			*cp.RingsConfig.RXBufLen = *o.RingsConfig.RXBufLen
		}
		if o.RingsConfig.CQESize != nil {
			cp.RingsConfig.CQESize = new(uint32)
			*cp.RingsConfig.CQESize = *o.RingsConfig.CQESize
		}
		if o.RingsConfig.TXPush != nil {
			cp.RingsConfig.TXPush = new(bool)
			*cp.RingsConfig.TXPush = *o.RingsConfig.TXPush
		}
		if o.RingsConfig.RXPush != nil {
			cp.RingsConfig.RXPush = new(bool)
			*cp.RingsConfig.RXPush = *o.RingsConfig.RXPush
		}
		if o.RingsConfig.TXPushBufLen != nil {
			cp.RingsConfig.TXPushBufLen = new(uint32)
			*cp.RingsConfig.TXPushBufLen = *o.RingsConfig.TXPushBufLen
		}
		if o.RingsConfig.TCPDataSplit != nil {
			cp.RingsConfig.TCPDataSplit = new(bool)
			*cp.RingsConfig.TCPDataSplit = *o.RingsConfig.TCPDataSplit
		}
	}
	if o.ChannelsConfig != nil {
		cp.ChannelsConfig = new(EthernetChannelsConfig)
		*cp.ChannelsConfig = *o.ChannelsConfig
		if o.ChannelsConfig.RX != nil {
			cp.ChannelsConfig.RX = new(uint32)
			*cp.ChannelsConfig.RX = *o.ChannelsConfig.RX
		}
		if o.ChannelsConfig.TX != nil {
			cp.ChannelsConfig.TX = new(uint32)
			*cp.ChannelsConfig.TX = *o.ChannelsConfig.TX
		}
		if o.ChannelsConfig.Other != nil {
			cp.ChannelsConfig.Other = new(uint32)
			*cp.ChannelsConfig.Other = *o.ChannelsConfig.Other
		}
		if o.ChannelsConfig.Combined != nil {
			cp.ChannelsConfig.Combined = new(uint32)
			*cp.ChannelsConfig.Combined = *o.ChannelsConfig.Combined
		}
	}
	if o.WakeOnLANConfig != nil {
		cp.WakeOnLANConfig = make([]nethelpers.WOLMode, len(o.WakeOnLANConfig))
		copy(cp.WakeOnLANConfig, o.WakeOnLANConfig)
	}
	return &cp
}

// DeepCopy generates a deep copy of *HCloudVIPConfigV1Alpha1.
func (o *HCloudVIPConfigV1Alpha1) DeepCopy() *HCloudVIPConfigV1Alpha1 {
	var cp HCloudVIPConfigV1Alpha1 = *o
	return &cp
}

// DeepCopy generates a deep copy of *HostnameConfigV1Alpha1.
func (o *HostnameConfigV1Alpha1) DeepCopy() *HostnameConfigV1Alpha1 {
	var cp HostnameConfigV1Alpha1 = *o
	if o.ConfigAuto != nil {
		cp.ConfigAuto = new(nethelpers.AutoHostnameKind)
		*cp.ConfigAuto = *o.ConfigAuto
	}
	return &cp
}

// DeepCopy generates a deep copy of *KubeSpanConfigV1Alpha1.
func (o *KubeSpanConfigV1Alpha1) DeepCopy() *KubeSpanConfigV1Alpha1 {
	var cp KubeSpanConfigV1Alpha1 = *o
	if o.ConfigEnabled != nil {
		cp.ConfigEnabled = new(bool)
		*cp.ConfigEnabled = *o.ConfigEnabled
	}
	if o.ConfigAdvertiseKubernetesNetworks != nil {
		cp.ConfigAdvertiseKubernetesNetworks = new(bool)
		*cp.ConfigAdvertiseKubernetesNetworks = *o.ConfigAdvertiseKubernetesNetworks
	}
	if o.ConfigAllowDownPeerBypass != nil {
		cp.ConfigAllowDownPeerBypass = new(bool)
		*cp.ConfigAllowDownPeerBypass = *o.ConfigAllowDownPeerBypass
	}
	if o.ConfigHarvestExtraEndpoints != nil {
		cp.ConfigHarvestExtraEndpoints = new(bool)
		*cp.ConfigHarvestExtraEndpoints = *o.ConfigHarvestExtraEndpoints
	}
	if o.ConfigMTU != nil {
		cp.ConfigMTU = new(uint32)
		*cp.ConfigMTU = *o.ConfigMTU
	}
	if o.ConfigFilters != nil {
		cp.ConfigFilters = new(KubeSpanFiltersConfig)
		*cp.ConfigFilters = *o.ConfigFilters
		if o.ConfigFilters.ConfigEndpoints != nil {
			cp.ConfigFilters.ConfigEndpoints = make([]string, len(o.ConfigFilters.ConfigEndpoints))
			copy(cp.ConfigFilters.ConfigEndpoints, o.ConfigFilters.ConfigEndpoints)
		}
	}
	return &cp
}

// DeepCopy generates a deep copy of *KubespanEndpointsConfigV1Alpha1.
func (o *KubespanEndpointsConfigV1Alpha1) DeepCopy() *KubespanEndpointsConfigV1Alpha1 {
	var cp KubespanEndpointsConfigV1Alpha1 = *o
	if o.ExtraAnnouncedEndpointsConfig != nil {
		cp.ExtraAnnouncedEndpointsConfig = make([]netip.AddrPort, len(o.ExtraAnnouncedEndpointsConfig))
		copy(cp.ExtraAnnouncedEndpointsConfig, o.ExtraAnnouncedEndpointsConfig)
	}
	return &cp
}

// DeepCopy generates a deep copy of *Layer2VIPConfigV1Alpha1.
func (o *Layer2VIPConfigV1Alpha1) DeepCopy() *Layer2VIPConfigV1Alpha1 {
	var cp Layer2VIPConfigV1Alpha1 = *o
	return &cp
}

// DeepCopy generates a deep copy of *LinkConfigV1Alpha1.
func (o *LinkConfigV1Alpha1) DeepCopy() *LinkConfigV1Alpha1 {
	var cp LinkConfigV1Alpha1 = *o
	if o.CommonLinkConfig.LinkUp != nil {
		cp.CommonLinkConfig.LinkUp = new(bool)
		*cp.CommonLinkConfig.LinkUp = *o.CommonLinkConfig.LinkUp
	}
	if o.CommonLinkConfig.LinkAddresses != nil {
		cp.CommonLinkConfig.LinkAddresses = make([]AddressConfig, len(o.CommonLinkConfig.LinkAddresses))
		copy(cp.CommonLinkConfig.LinkAddresses, o.CommonLinkConfig.LinkAddresses)
		for i3 := range o.CommonLinkConfig.LinkAddresses {
			if o.CommonLinkConfig.LinkAddresses[i3].AddressPriority != nil {
				cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = new(uint32)
				*cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = *o.CommonLinkConfig.LinkAddresses[i3].AddressPriority
			}
		}
	}
	if o.CommonLinkConfig.LinkRoutes != nil {
		cp.CommonLinkConfig.LinkRoutes = make([]RouteConfig, len(o.CommonLinkConfig.LinkRoutes))
		copy(cp.CommonLinkConfig.LinkRoutes, o.CommonLinkConfig.LinkRoutes)
	}
	if o.CommonLinkConfig.LinkMulticast != nil {
		cp.CommonLinkConfig.LinkMulticast = new(bool)
		*cp.CommonLinkConfig.LinkMulticast = *o.CommonLinkConfig.LinkMulticast
	}
	return &cp
}

// DeepCopy generates a deep copy of *LinkAliasConfigV1Alpha1.
func (o *LinkAliasConfigV1Alpha1) DeepCopy() *LinkAliasConfigV1Alpha1 {
	var cp LinkAliasConfigV1Alpha1 = *o
	if o.Selector.RequireUniqueMatch != nil {
		cp.Selector.RequireUniqueMatch = new(bool)
		*cp.Selector.RequireUniqueMatch = *o.Selector.RequireUniqueMatch
	}
	if o.Selector.SkipAliasedLinks != nil {
		cp.Selector.SkipAliasedLinks = new(bool)
		*cp.Selector.SkipAliasedLinks = *o.Selector.SkipAliasedLinks
	}
	return &cp
}

// DeepCopy generates a deep copy of *ResolverConfigV1Alpha1.
func (o *ResolverConfigV1Alpha1) DeepCopy() *ResolverConfigV1Alpha1 {
	var cp ResolverConfigV1Alpha1 = *o
	if o.ResolverNameservers != nil {
		cp.ResolverNameservers = make([]NameserverConfig, len(o.ResolverNameservers))
		copy(cp.ResolverNameservers, o.ResolverNameservers)
	}
	if o.ResolverSearchDomains.SearchDomains != nil {
		cp.ResolverSearchDomains.SearchDomains = make([]string, len(o.ResolverSearchDomains.SearchDomains))
		copy(cp.ResolverSearchDomains.SearchDomains, o.ResolverSearchDomains.SearchDomains)
	}
	if o.ResolverSearchDomains.SearchDisableDefault != nil {
		cp.ResolverSearchDomains.SearchDisableDefault = new(bool)
		*cp.ResolverSearchDomains.SearchDisableDefault = *o.ResolverSearchDomains.SearchDisableDefault
	}
	return &cp
}

// DeepCopy generates a deep copy of *RuleConfigV1Alpha1.
func (o *RuleConfigV1Alpha1) DeepCopy() *RuleConfigV1Alpha1 {
	var cp RuleConfigV1Alpha1 = *o
	if o.PortSelector.Ports != nil {
		cp.PortSelector.Ports = make([]PortRange, len(o.PortSelector.Ports))
		copy(cp.PortSelector.Ports, o.PortSelector.Ports)
	}
	if o.Ingress != nil {
		cp.Ingress = make([]IngressRule, len(o.Ingress))
		copy(cp.Ingress, o.Ingress)
	}
	return &cp
}

// DeepCopy generates a deep copy of *StaticHostConfigV1Alpha1.
func (o *StaticHostConfigV1Alpha1) DeepCopy() *StaticHostConfigV1Alpha1 {
	var cp StaticHostConfigV1Alpha1 = *o
	if o.Hostnames != nil {
		cp.Hostnames = make([]string, len(o.Hostnames))
		copy(cp.Hostnames, o.Hostnames)
	}
	return &cp
}

// DeepCopy generates a deep copy of *TCPProbeConfigV1Alpha1.
func (o *TCPProbeConfigV1Alpha1) DeepCopy() *TCPProbeConfigV1Alpha1 {
	var cp TCPProbeConfigV1Alpha1 = *o
	return &cp
}

// DeepCopy generates a deep copy of *TimeSyncConfigV1Alpha1.
func (o *TimeSyncConfigV1Alpha1) DeepCopy() *TimeSyncConfigV1Alpha1 {
	var cp TimeSyncConfigV1Alpha1 = *o
	if o.TimeEnabled != nil {
		cp.TimeEnabled = new(bool)
		*cp.TimeEnabled = *o.TimeEnabled
	}
	if o.TimeNTP != nil {
		cp.TimeNTP = new(NTPConfig)
		*cp.TimeNTP = *o.TimeNTP
		if o.TimeNTP.Servers != nil {
			cp.TimeNTP.Servers = make([]string, len(o.TimeNTP.Servers))
			copy(cp.TimeNTP.Servers, o.TimeNTP.Servers)
		}
	}
	if o.TimePTP != nil {
		cp.TimePTP = new(PTPConfig)
		*cp.TimePTP = *o.TimePTP
		if o.TimePTP.Devices != nil {
			cp.TimePTP.Devices = make([]string, len(o.TimePTP.Devices))
			copy(cp.TimePTP.Devices, o.TimePTP.Devices)
		}
	}
	return &cp
}

// DeepCopy generates a deep copy of *VLANConfigV1Alpha1.
func (o *VLANConfigV1Alpha1) DeepCopy() *VLANConfigV1Alpha1 {
	var cp VLANConfigV1Alpha1 = *o
	if o.VLANModeConfig != nil {
		cp.VLANModeConfig = new(nethelpers.VLANProtocol)
		*cp.VLANModeConfig = *o.VLANModeConfig
	}
	if o.CommonLinkConfig.LinkUp != nil {
		cp.CommonLinkConfig.LinkUp = new(bool)
		*cp.CommonLinkConfig.LinkUp = *o.CommonLinkConfig.LinkUp
	}
	if o.CommonLinkConfig.LinkAddresses != nil {
		cp.CommonLinkConfig.LinkAddresses = make([]AddressConfig, len(o.CommonLinkConfig.LinkAddresses))
		copy(cp.CommonLinkConfig.LinkAddresses, o.CommonLinkConfig.LinkAddresses)
		for i3 := range o.CommonLinkConfig.LinkAddresses {
			if o.CommonLinkConfig.LinkAddresses[i3].AddressPriority != nil {
				cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = new(uint32)
				*cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = *o.CommonLinkConfig.LinkAddresses[i3].AddressPriority
			}
		}
	}
	if o.CommonLinkConfig.LinkRoutes != nil {
		cp.CommonLinkConfig.LinkRoutes = make([]RouteConfig, len(o.CommonLinkConfig.LinkRoutes))
		copy(cp.CommonLinkConfig.LinkRoutes, o.CommonLinkConfig.LinkRoutes)
	}
	if o.CommonLinkConfig.LinkMulticast != nil {
		cp.CommonLinkConfig.LinkMulticast = new(bool)
		*cp.CommonLinkConfig.LinkMulticast = *o.CommonLinkConfig.LinkMulticast
	}
	return &cp
}

// DeepCopy generates a deep copy of *WireguardConfigV1Alpha1.
func (o *WireguardConfigV1Alpha1) DeepCopy() *WireguardConfigV1Alpha1 {
	var cp WireguardConfigV1Alpha1 = *o
	if o.WireguardPeers != nil {
		cp.WireguardPeers = make([]WireguardPeer, len(o.WireguardPeers))
		copy(cp.WireguardPeers, o.WireguardPeers)
		for i2 := range o.WireguardPeers {
			if o.WireguardPeers[i2].WireguardAllowedIPs != nil {
				cp.WireguardPeers[i2].WireguardAllowedIPs = make([]Prefix, len(o.WireguardPeers[i2].WireguardAllowedIPs))
				copy(cp.WireguardPeers[i2].WireguardAllowedIPs, o.WireguardPeers[i2].WireguardAllowedIPs)
			}
		}
	}
	if o.CommonLinkConfig.LinkUp != nil {
		cp.CommonLinkConfig.LinkUp = new(bool)
		*cp.CommonLinkConfig.LinkUp = *o.CommonLinkConfig.LinkUp
	}
	if o.CommonLinkConfig.LinkAddresses != nil {
		cp.CommonLinkConfig.LinkAddresses = make([]AddressConfig, len(o.CommonLinkConfig.LinkAddresses))
		copy(cp.CommonLinkConfig.LinkAddresses, o.CommonLinkConfig.LinkAddresses)
		for i3 := range o.CommonLinkConfig.LinkAddresses {
			if o.CommonLinkConfig.LinkAddresses[i3].AddressPriority != nil {
				cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = new(uint32)
				*cp.CommonLinkConfig.LinkAddresses[i3].AddressPriority = *o.CommonLinkConfig.LinkAddresses[i3].AddressPriority
			}
		}
	}
	if o.CommonLinkConfig.LinkRoutes != nil {
		cp.CommonLinkConfig.LinkRoutes = make([]RouteConfig, len(o.CommonLinkConfig.LinkRoutes))
		copy(cp.CommonLinkConfig.LinkRoutes, o.CommonLinkConfig.LinkRoutes)
	}
	if o.CommonLinkConfig.LinkMulticast != nil {
		cp.CommonLinkConfig.LinkMulticast = new(bool)
		*cp.CommonLinkConfig.LinkMulticast = *o.CommonLinkConfig.LinkMulticast
	}
	return &cp
}

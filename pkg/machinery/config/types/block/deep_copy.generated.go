// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by "deep-copy -type SwapVolumeConfigV1Alpha1 -type UserVolumeConfigV1Alpha1 -type VolumeConfigV1Alpha1 -pointer-receiver -header-file ../../../../../hack/boilerplate.txt -o deep_copy.generated.go ."; DO NOT EDIT.

package block

// DeepCopy generates a deep copy of *SwapVolumeConfigV1Alpha1.
func (o *SwapVolumeConfigV1Alpha1) DeepCopy() *SwapVolumeConfigV1Alpha1 {
	var cp SwapVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMaxSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.value
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMaxSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.raw)
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *UserVolumeConfigV1Alpha1.
func (o *UserVolumeConfigV1Alpha1) DeepCopy() *UserVolumeConfigV1Alpha1 {
	var cp UserVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMaxSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.value
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMaxSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.raw)
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *VolumeConfigV1Alpha1.
func (o *VolumeConfigV1Alpha1) DeepCopy() *VolumeConfigV1Alpha1 {
	var cp VolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMaxSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.value
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMaxSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.raw)
	}
	return &cp
}

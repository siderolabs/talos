// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by "deep-copy -type ExistingVolumeConfigV1Alpha1 -type RawVolumeConfigV1Alpha1 -type SwapVolumeConfigV1Alpha1 -type UserVolumeConfigV1Alpha1 -type ExternalVolumeConfigV1Alpha1 -type VolumeConfigV1Alpha1 -type ZswapConfigV1Alpha1 -type LVMPhysicalVolumeV1Alpha1 -type LVMVolumeGroupV1Alpha1 -type LVMLogicalVolumeV1Alpha1 -pointer-receiver -header-file ../../../../../hack/boilerplate.txt -o deep_copy.generated.go ."; DO NOT EDIT.

package block

// DeepCopy generates a deep copy of *ExistingVolumeConfigV1Alpha1.
func (o *ExistingVolumeConfigV1Alpha1) DeepCopy() *ExistingVolumeConfigV1Alpha1 {
	var cp ExistingVolumeConfigV1Alpha1 = *o
	if o.MountSpec.MountReadOnly != nil {
		cp.MountSpec.MountReadOnly = new(bool)
		*cp.MountSpec.MountReadOnly = *o.MountSpec.MountReadOnly
	}
	return &cp
}

// DeepCopy generates a deep copy of *RawVolumeConfigV1Alpha1.
func (o *RawVolumeConfigV1Alpha1) DeepCopy() *RawVolumeConfigV1Alpha1 {
	var cp RawVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *SwapVolumeConfigV1Alpha1.
func (o *SwapVolumeConfigV1Alpha1) DeepCopy() *SwapVolumeConfigV1Alpha1 {
	var cp SwapVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *UserVolumeConfigV1Alpha1.
func (o *UserVolumeConfigV1Alpha1) DeepCopy() *UserVolumeConfigV1Alpha1 {
	var cp UserVolumeConfigV1Alpha1 = *o
	if o.VolumeType != nil {
		cp.VolumeType = new(VolumeType)
		*cp.VolumeType = *o.VolumeType
	}
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.FilesystemSpec.ProjectQuotaSupportConfig != nil {
		cp.FilesystemSpec.ProjectQuotaSupportConfig = new(bool)
		*cp.FilesystemSpec.ProjectQuotaSupportConfig = *o.FilesystemSpec.ProjectQuotaSupportConfig
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *ExternalVolumeConfigV1Alpha1.
func (o *ExternalVolumeConfigV1Alpha1) DeepCopy() *ExternalVolumeConfigV1Alpha1 {
	var cp ExternalVolumeConfigV1Alpha1 = *o
	if o.MountSpec.MountReadOnly != nil {
		cp.MountSpec.MountReadOnly = new(bool)
		*cp.MountSpec.MountReadOnly = *o.MountSpec.MountReadOnly
	}
	if o.MountSpec.MountVirtiofs != nil {
		cp.MountSpec.MountVirtiofs = new(VirtiofsMountSpec)
		*cp.MountSpec.MountVirtiofs = *o.MountSpec.MountVirtiofs
	}
	return &cp
}

// DeepCopy generates a deep copy of *VolumeConfigV1Alpha1.
func (o *VolumeConfigV1Alpha1) DeepCopy() *VolumeConfigV1Alpha1 {
	var cp VolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *ZswapConfigV1Alpha1.
func (o *ZswapConfigV1Alpha1) DeepCopy() *ZswapConfigV1Alpha1 {
	var cp ZswapConfigV1Alpha1 = *o
	if o.MaxPoolPercentConfig != nil {
		cp.MaxPoolPercentConfig = new(int)
		*cp.MaxPoolPercentConfig = *o.MaxPoolPercentConfig
	}
	if o.ShrinkerEnabledConfig != nil {
		cp.ShrinkerEnabledConfig = new(bool)
		*cp.ShrinkerEnabledConfig = *o.ShrinkerEnabledConfig
	}
	return &cp
}

// DeepCopy generates a deep copy of *LVMPhysicalVolumeV1Alpha1.
func (o *LVMPhysicalVolumeV1Alpha1) DeepCopy() *LVMPhysicalVolumeV1Alpha1 {
	var cp LVMPhysicalVolumeV1Alpha1 = *o
	return &cp
}

// DeepCopy generates a deep copy of *LVMVolumeGroupV1Alpha1.
func (o *LVMVolumeGroupV1Alpha1) DeepCopy() *LVMVolumeGroupV1Alpha1 {
	var cp LVMVolumeGroupV1Alpha1 = *o
	return &cp
}

// DeepCopy generates a deep copy of *LVMLogicalVolumeV1Alpha1.
func (o *LVMLogicalVolumeV1Alpha1) DeepCopy() *LVMLogicalVolumeV1Alpha1 {
	var cp LVMLogicalVolumeV1Alpha1 = *o
	if o.Provisioning.MinSize.value != nil {
		cp.Provisioning.MinSize.value = new(uint64)
		*cp.Provisioning.MinSize.value = *o.Provisioning.MinSize.value
	}
	if o.Provisioning.MinSize.raw != nil {
		cp.Provisioning.MinSize.raw = make([]byte, len(o.Provisioning.MinSize.raw))
		copy(cp.Provisioning.MinSize.raw, o.Provisioning.MinSize.raw)
	}
	if o.Provisioning.MaxSize.PercentageSize != nil {
		cp.Provisioning.MaxSize.PercentageSize = new(PercentageSize)
		*cp.Provisioning.MaxSize.PercentageSize = *o.Provisioning.MaxSize.PercentageSize
		if o.Provisioning.MaxSize.PercentageSize.value != nil {
			cp.Provisioning.MaxSize.PercentageSize.value = new(uint64)
			*cp.Provisioning.MaxSize.PercentageSize.value = *o.Provisioning.MaxSize.PercentageSize.value
		}
		if o.Provisioning.MaxSize.PercentageSize.raw != nil {
			cp.Provisioning.MaxSize.PercentageSize.raw = make([]byte, len(o.Provisioning.MaxSize.PercentageSize.raw))
			copy(cp.Provisioning.MaxSize.PercentageSize.raw, o.Provisioning.MaxSize.PercentageSize.raw)
		}
	}
	if o.Provisioning.MaxSize.ByteSize != nil {
		cp.Provisioning.MaxSize.ByteSize = new(ByteSize)
		*cp.Provisioning.MaxSize.ByteSize = *o.Provisioning.MaxSize.ByteSize
		if o.Provisioning.MaxSize.ByteSize.value != nil {
			cp.Provisioning.MaxSize.ByteSize.value = new(uint64)
			*cp.Provisioning.MaxSize.ByteSize.value = *o.Provisioning.MaxSize.ByteSize.value
		}
		if o.Provisioning.MaxSize.ByteSize.raw != nil {
			cp.Provisioning.MaxSize.ByteSize.raw = make([]byte, len(o.Provisioning.MaxSize.ByteSize.raw))
			copy(cp.Provisioning.MaxSize.ByteSize.raw, o.Provisioning.MaxSize.ByteSize.raw)
		}
	}
	return &cp
}

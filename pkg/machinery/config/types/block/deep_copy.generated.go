// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by "deep-copy -type ExistingVolumeConfigV1Alpha1 -type RawVolumeConfigV1Alpha1 -type SwapVolumeConfigV1Alpha1 -type UserVolumeConfigV1Alpha1 -type ExternalVolumeConfigV1Alpha1 -type VolumeConfigV1Alpha1 -type ZswapConfigV1Alpha1 -type LVMVolumeConfigV1Alpha1 -pointer-receiver -header-file ../../../../../hack/boilerplate.txt -o deep_copy.generated.go ."; DO NOT EDIT.

package block

// DeepCopy generates a deep copy of *ExistingVolumeConfigV1Alpha1.
func (o *ExistingVolumeConfigV1Alpha1) DeepCopy() *ExistingVolumeConfigV1Alpha1 {
	var cp ExistingVolumeConfigV1Alpha1 = *o
	if o.MountSpec.MountReadOnly != nil {
		cp.MountSpec.MountReadOnly = new(bool)
		*cp.MountSpec.MountReadOnly = *o.MountSpec.MountReadOnly
	}
	return &cp
}

// DeepCopy generates a deep copy of *RawVolumeConfigV1Alpha1.
func (o *RawVolumeConfigV1Alpha1) DeepCopy() *RawVolumeConfigV1Alpha1 {
	var cp RawVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *SwapVolumeConfigV1Alpha1.
func (o *SwapVolumeConfigV1Alpha1) DeepCopy() *SwapVolumeConfigV1Alpha1 {
	var cp SwapVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *UserVolumeConfigV1Alpha1.
func (o *UserVolumeConfigV1Alpha1) DeepCopy() *UserVolumeConfigV1Alpha1 {
	var cp UserVolumeConfigV1Alpha1 = *o
	if o.VolumeType != nil {
		cp.VolumeType = new(VolumeType)
		*cp.VolumeType = *o.VolumeType
	}
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.FilesystemSpec.ProjectQuotaSupportConfig != nil {
		cp.FilesystemSpec.ProjectQuotaSupportConfig = new(bool)
		*cp.FilesystemSpec.ProjectQuotaSupportConfig = *o.FilesystemSpec.ProjectQuotaSupportConfig
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *ExternalVolumeConfigV1Alpha1.
func (o *ExternalVolumeConfigV1Alpha1) DeepCopy() *ExternalVolumeConfigV1Alpha1 {
	var cp ExternalVolumeConfigV1Alpha1 = *o
	if o.MountSpec.MountReadOnly != nil {
		cp.MountSpec.MountReadOnly = new(bool)
		*cp.MountSpec.MountReadOnly = *o.MountSpec.MountReadOnly
	}
	if o.MountSpec.MountVirtiofs != nil {
		cp.MountSpec.MountVirtiofs = new(VirtiofsMountSpec)
		*cp.MountSpec.MountVirtiofs = *o.MountSpec.MountVirtiofs
	}
	return &cp
}

// DeepCopy generates a deep copy of *VolumeConfigV1Alpha1.
func (o *VolumeConfigV1Alpha1) DeepCopy() *VolumeConfigV1Alpha1 {
	var cp VolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.value != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.value = new(uint64)
		*cp.ProvisioningSpec.ProvisioningMinSize.value = *o.ProvisioningSpec.ProvisioningMinSize.value
	}
	if o.ProvisioningSpec.ProvisioningMinSize.raw != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.raw))
		copy(cp.ProvisioningSpec.ProvisioningMinSize.raw, o.ProvisioningSpec.ProvisioningMinSize.raw)
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.PercentageSize.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value = *o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw, o.ProvisioningSpec.ProvisioningMaxSize.ByteSize.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *ZswapConfigV1Alpha1.
func (o *ZswapConfigV1Alpha1) DeepCopy() *ZswapConfigV1Alpha1 {
	var cp ZswapConfigV1Alpha1 = *o
	if o.MaxPoolPercentConfig != nil {
		cp.MaxPoolPercentConfig = new(int)
		*cp.MaxPoolPercentConfig = *o.MaxPoolPercentConfig
	}
	if o.ShrinkerEnabledConfig != nil {
		cp.ShrinkerEnabledConfig = new(bool)
		*cp.ShrinkerEnabledConfig = *o.ShrinkerEnabledConfig
	}
	return &cp
}

// DeepCopy generates a deep copy of *LVMVolumeConfigV1Alpha1.
func (o *LVMVolumeConfigV1Alpha1) DeepCopy() *LVMVolumeConfigV1Alpha1 {
	var cp LVMVolumeConfigV1Alpha1 = *o
	if o.PhysicalVolumes != nil {
		cp.PhysicalVolumes = make([]LVMPhysicalVolumeConfig, len(o.PhysicalVolumes))
		copy(cp.PhysicalVolumes, o.PhysicalVolumes)
	}
	if o.VolumeGroups != nil {
		cp.VolumeGroups = make([]LVMVolumeGroupConfig, len(o.VolumeGroups))
		copy(cp.VolumeGroups, o.VolumeGroups)
		for i2 := range o.VolumeGroups {
			if o.VolumeGroups[i2].PhysicalVolumes != nil {
				cp.VolumeGroups[i2].PhysicalVolumes = make([]string, len(o.VolumeGroups[i2].PhysicalVolumes))
				copy(cp.VolumeGroups[i2].PhysicalVolumes, o.VolumeGroups[i2].PhysicalVolumes)
			}
			if o.VolumeGroups[i2].ExtentSize != nil {
				cp.VolumeGroups[i2].ExtentSize = new(ByteSize)
				*cp.VolumeGroups[i2].ExtentSize = *o.VolumeGroups[i2].ExtentSize
				if o.VolumeGroups[i2].ExtentSize.value != nil {
					cp.VolumeGroups[i2].ExtentSize.value = new(uint64)
					*cp.VolumeGroups[i2].ExtentSize.value = *o.VolumeGroups[i2].ExtentSize.value
				}
				if o.VolumeGroups[i2].ExtentSize.raw != nil {
					cp.VolumeGroups[i2].ExtentSize.raw = make([]byte, len(o.VolumeGroups[i2].ExtentSize.raw))
					copy(cp.VolumeGroups[i2].ExtentSize.raw, o.VolumeGroups[i2].ExtentSize.raw)
				}
			}
		}
	}
	if o.LogicalVolumes != nil {
		cp.LogicalVolumes = make([]LVMLogicalVolumeConfig, len(o.LogicalVolumes))
		copy(cp.LogicalVolumes, o.LogicalVolumes)
		for i2 := range o.LogicalVolumes {
			if o.LogicalVolumes[i2].Size.value != nil {
				cp.LogicalVolumes[i2].Size.value = new(uint64)
				*cp.LogicalVolumes[i2].Size.value = *o.LogicalVolumes[i2].Size.value
			}
			if o.LogicalVolumes[i2].Size.raw != nil {
				cp.LogicalVolumes[i2].Size.raw = make([]byte, len(o.LogicalVolumes[i2].Size.raw))
				copy(cp.LogicalVolumes[i2].Size.raw, o.LogicalVolumes[i2].Size.raw)
			}
			if o.LogicalVolumes[i2].Type != nil {
				cp.LogicalVolumes[i2].Type = new(LVType)
				*cp.LogicalVolumes[i2].Type = *o.LogicalVolumes[i2].Type
			}
			if o.LogicalVolumes[i2].Filesystem != nil {
				cp.LogicalVolumes[i2].Filesystem = new(FilesystemSpec)
				*cp.LogicalVolumes[i2].Filesystem = *o.LogicalVolumes[i2].Filesystem
				if o.LogicalVolumes[i2].Filesystem.ProjectQuotaSupportConfig != nil {
					cp.LogicalVolumes[i2].Filesystem.ProjectQuotaSupportConfig = new(bool)
					*cp.LogicalVolumes[i2].Filesystem.ProjectQuotaSupportConfig = *o.LogicalVolumes[i2].Filesystem.ProjectQuotaSupportConfig
				}
			}
			if o.LogicalVolumes[i2].Mount != nil {
				cp.LogicalVolumes[i2].Mount = new(LVMMountSpec)
				*cp.LogicalVolumes[i2].Mount = *o.LogicalVolumes[i2].Mount
				if o.LogicalVolumes[i2].Mount.Options != nil {
					cp.LogicalVolumes[i2].Mount.Options = make([]string, len(o.LogicalVolumes[i2].Mount.Options))
					copy(cp.LogicalVolumes[i2].Mount.Options, o.LogicalVolumes[i2].Mount.Options)
				}
			}
			if o.LogicalVolumes[i2].Encryption != nil {
				cp.LogicalVolumes[i2].Encryption = new(EncryptionSpec)
				*cp.LogicalVolumes[i2].Encryption = *o.LogicalVolumes[i2].Encryption
				if o.LogicalVolumes[i2].Encryption.EncryptionKeys != nil {
					cp.LogicalVolumes[i2].Encryption.EncryptionKeys = make([]EncryptionKey, len(o.LogicalVolumes[i2].Encryption.EncryptionKeys))
					copy(cp.LogicalVolumes[i2].Encryption.EncryptionKeys, o.LogicalVolumes[i2].Encryption.EncryptionKeys)
					for i6 := range o.LogicalVolumes[i2].Encryption.EncryptionKeys {
						if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyStatic != nil {
							cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyStatic = new(EncryptionKeyStatic)
							*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyStatic = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyStatic
						}
						if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyNodeID != nil {
							cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyNodeID = new(EncryptionKeyNodeID)
							*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyNodeID = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyNodeID
						}
						if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyKMS != nil {
							cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyKMS = new(EncryptionKeyKMS)
							*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyKMS = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyKMS
						}
						if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM != nil {
							cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM = new(EncryptionKeyTPM)
							*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM
							if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions != nil {
								cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
								*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions
								if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions.PCRs != nil {
									cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions.PCRs = make([]int, len(o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions.PCRs))
									copy(cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions.PCRs, o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMOptions.PCRs)
								}
							}
							if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
								cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
								*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyTPM.TPMCheckSecurebootStatusOnEnroll
							}
						}
						if o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyLockToSTATE != nil {
							cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyLockToSTATE = new(bool)
							*cp.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyLockToSTATE = *o.LogicalVolumes[i2].Encryption.EncryptionKeys[i6].KeyLockToSTATE
						}
					}
				}
				if o.LogicalVolumes[i2].Encryption.EncryptionPerfOptions != nil {
					cp.LogicalVolumes[i2].Encryption.EncryptionPerfOptions = make([]string, len(o.LogicalVolumes[i2].Encryption.EncryptionPerfOptions))
					copy(cp.LogicalVolumes[i2].Encryption.EncryptionPerfOptions, o.LogicalVolumes[i2].Encryption.EncryptionPerfOptions)
				}
			}
		}
	}
	return &cp
}

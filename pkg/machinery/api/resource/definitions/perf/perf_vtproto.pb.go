// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: v0.6.0
// source: resource/definitions/perf/perf.proto

package perf

import (
	binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"

	protohelpers "github.com/planetscale/vtprotobuf/protohelpers"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *CPUSpec) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUSpec) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CPUSpec) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.SoftIrqTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.SoftIrqTotal))
		i--
		dAtA[i] = 0x40
	}
	if m.ProcessBlocked != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ProcessBlocked))
		i--
		dAtA[i] = 0x38
	}
	if m.ProcessRunning != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ProcessRunning))
		i--
		dAtA[i] = 0x30
	}
	if m.ProcessCreated != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ProcessCreated))
		i--
		dAtA[i] = 0x28
	}
	if m.ContextSwitches != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ContextSwitches))
		i--
		dAtA[i] = 0x20
	}
	if m.IrqTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.IrqTotal))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuTotal != nil {
		size, err := m.CpuTotal.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cpu) > 0 {
		for iNdEx := len(m.Cpu) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Cpu[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CPUStat) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUStat) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CPUStat) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.GuestNice != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GuestNice))))
		i--
		dAtA[i] = 0x51
	}
	if m.Guest != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Guest))))
		i--
		dAtA[i] = 0x49
	}
	if m.Steal != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Steal))))
		i--
		dAtA[i] = 0x41
	}
	if m.SoftIrq != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SoftIrq))))
		i--
		dAtA[i] = 0x39
	}
	if m.Irq != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Irq))))
		i--
		dAtA[i] = 0x31
	}
	if m.Iowait != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Iowait))))
		i--
		dAtA[i] = 0x29
	}
	if m.Idle != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Idle))))
		i--
		dAtA[i] = 0x21
	}
	if m.System != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.System))))
		i--
		dAtA[i] = 0x19
	}
	if m.Nice != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Nice))))
		i--
		dAtA[i] = 0x11
	}
	if m.User != 0 {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.User))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MemorySpec) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemorySpec) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MemorySpec) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.DirectMap1G != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.DirectMap1G))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.DirectMap2M != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.DirectMap2M))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.DirectMap4K != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.DirectMap4K))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.Hugepagesize != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Hugepagesize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.HugePagesSurp != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.HugePagesSurp))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.HugePagesRsvd != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.HugePagesRsvd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.HugePagesFree != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.HugePagesFree))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.HugePagesTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.HugePagesTotal))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.CmaFree != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CmaFree))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.CmaTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CmaTotal))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ShmemPmdMapped != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ShmemPmdMapped))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.ShmemHugePages != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ShmemHugePages))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.AnonHugePages != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AnonHugePages))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.HardwareCorrupted != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.HardwareCorrupted))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.VmallocChunk != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.VmallocChunk))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.VmallocUsed != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.VmallocUsed))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.VmallocTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.VmallocTotal))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.CommittedAs != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CommittedAs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CommitLimit != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CommitLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.WritebackTmp != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.WritebackTmp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.Bounce != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Bounce))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.NfSunstable != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.NfSunstable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.PageTables != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.PageTables))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.KernelStack != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.KernelStack))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.SUnreclaim != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.SUnreclaim))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.SReclaimable != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.SReclaimable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Slab != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Slab))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Shmem != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Shmem))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Mapped != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Mapped))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AnonPages != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.AnonPages))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Writeback != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Writeback))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Dirty != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Dirty))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SwapFree != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.SwapFree))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SwapTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.SwapTotal))
		i--
		dAtA[i] = 0x78
	}
	if m.Mlocked != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Mlocked))
		i--
		dAtA[i] = 0x70
	}
	if m.Unevictable != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Unevictable))
		i--
		dAtA[i] = 0x68
	}
	if m.InactiveFile != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.InactiveFile))
		i--
		dAtA[i] = 0x60
	}
	if m.ActiveFile != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ActiveFile))
		i--
		dAtA[i] = 0x58
	}
	if m.InactiveAnon != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.InactiveAnon))
		i--
		dAtA[i] = 0x50
	}
	if m.ActiveAnon != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ActiveAnon))
		i--
		dAtA[i] = 0x48
	}
	if m.Inactive != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Inactive))
		i--
		dAtA[i] = 0x40
	}
	if m.Active != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Active))
		i--
		dAtA[i] = 0x38
	}
	if m.SwapCached != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.SwapCached))
		i--
		dAtA[i] = 0x30
	}
	if m.Cached != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Cached))
		i--
		dAtA[i] = 0x28
	}
	if m.Buffers != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Buffers))
		i--
		dAtA[i] = 0x20
	}
	if m.MemAvailable != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MemAvailable))
		i--
		dAtA[i] = 0x18
	}
	if m.MemUsed != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MemUsed))
		i--
		dAtA[i] = 0x10
	}
	if m.MemTotal != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MemTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPUSpec) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cpu) > 0 {
		for _, e := range m.Cpu {
			l = e.SizeVT()
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if m.CpuTotal != nil {
		l = m.CpuTotal.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.IrqTotal != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.IrqTotal))
	}
	if m.ContextSwitches != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.ContextSwitches))
	}
	if m.ProcessCreated != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.ProcessCreated))
	}
	if m.ProcessRunning != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.ProcessRunning))
	}
	if m.ProcessBlocked != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.ProcessBlocked))
	}
	if m.SoftIrqTotal != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.SoftIrqTotal))
	}
	n += len(m.unknownFields)
	return n
}

func (m *CPUStat) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.User != 0 {
		n += 9
	}
	if m.Nice != 0 {
		n += 9
	}
	if m.System != 0 {
		n += 9
	}
	if m.Idle != 0 {
		n += 9
	}
	if m.Iowait != 0 {
		n += 9
	}
	if m.Irq != 0 {
		n += 9
	}
	if m.SoftIrq != 0 {
		n += 9
	}
	if m.Steal != 0 {
		n += 9
	}
	if m.Guest != 0 {
		n += 9
	}
	if m.GuestNice != 0 {
		n += 9
	}
	n += len(m.unknownFields)
	return n
}

func (m *MemorySpec) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemTotal != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MemTotal))
	}
	if m.MemUsed != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MemUsed))
	}
	if m.MemAvailable != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.MemAvailable))
	}
	if m.Buffers != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Buffers))
	}
	if m.Cached != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Cached))
	}
	if m.SwapCached != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.SwapCached))
	}
	if m.Active != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Active))
	}
	if m.Inactive != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Inactive))
	}
	if m.ActiveAnon != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.ActiveAnon))
	}
	if m.InactiveAnon != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.InactiveAnon))
	}
	if m.ActiveFile != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.ActiveFile))
	}
	if m.InactiveFile != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.InactiveFile))
	}
	if m.Unevictable != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Unevictable))
	}
	if m.Mlocked != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Mlocked))
	}
	if m.SwapTotal != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.SwapTotal))
	}
	if m.SwapFree != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.SwapFree))
	}
	if m.Dirty != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Dirty))
	}
	if m.Writeback != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Writeback))
	}
	if m.AnonPages != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AnonPages))
	}
	if m.Mapped != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Mapped))
	}
	if m.Shmem != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Shmem))
	}
	if m.Slab != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Slab))
	}
	if m.SReclaimable != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.SReclaimable))
	}
	if m.SUnreclaim != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.SUnreclaim))
	}
	if m.KernelStack != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.KernelStack))
	}
	if m.PageTables != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.PageTables))
	}
	if m.NfSunstable != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.NfSunstable))
	}
	if m.Bounce != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Bounce))
	}
	if m.WritebackTmp != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.WritebackTmp))
	}
	if m.CommitLimit != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CommitLimit))
	}
	if m.CommittedAs != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CommittedAs))
	}
	if m.VmallocTotal != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.VmallocTotal))
	}
	if m.VmallocUsed != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.VmallocUsed))
	}
	if m.VmallocChunk != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.VmallocChunk))
	}
	if m.HardwareCorrupted != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.HardwareCorrupted))
	}
	if m.AnonHugePages != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.AnonHugePages))
	}
	if m.ShmemHugePages != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.ShmemHugePages))
	}
	if m.ShmemPmdMapped != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.ShmemPmdMapped))
	}
	if m.CmaTotal != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CmaTotal))
	}
	if m.CmaFree != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CmaFree))
	}
	if m.HugePagesTotal != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.HugePagesTotal))
	}
	if m.HugePagesFree != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.HugePagesFree))
	}
	if m.HugePagesRsvd != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.HugePagesRsvd))
	}
	if m.HugePagesSurp != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.HugePagesSurp))
	}
	if m.Hugepagesize != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Hugepagesize))
	}
	if m.DirectMap4K != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.DirectMap4K))
	}
	if m.DirectMap2M != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.DirectMap2M))
	}
	if m.DirectMap1G != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.DirectMap1G))
	}
	n += len(m.unknownFields)
	return n
}

func (m *CPUSpec) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = append(m.Cpu, &CPUStat{})
			if err := m.Cpu[len(m.Cpu)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuTotal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuTotal == nil {
				m.CpuTotal = &CPUStat{}
			}
			if err := m.CpuTotal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrqTotal", wireType)
			}
			m.IrqTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IrqTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextSwitches", wireType)
			}
			m.ContextSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContextSwitches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessCreated", wireType)
			}
			m.ProcessCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessCreated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessRunning", wireType)
			}
			m.ProcessRunning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessRunning |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessBlocked", wireType)
			}
			m.ProcessBlocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessBlocked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftIrqTotal", wireType)
			}
			m.SoftIrqTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoftIrqTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUStat) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.User = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Nice = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.System = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Idle = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Iowait = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Irq = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftIrq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SoftIrq = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Steal = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Guest = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuestNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GuestNice = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemorySpec) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemorySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemorySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			m.MemTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsed", wireType)
			}
			m.MemUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAvailable", wireType)
			}
			m.MemAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemAvailable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffers", wireType)
			}
			m.Buffers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buffers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cached", wireType)
			}
			m.Cached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cached |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapCached", wireType)
			}
			m.SwapCached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapCached |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Active |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			m.Inactive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inactive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAnon", wireType)
			}
			m.ActiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveAnon |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveAnon", wireType)
			}
			m.InactiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveAnon |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFile", wireType)
			}
			m.ActiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFile |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveFile", wireType)
			}
			m.InactiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveFile |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unevictable", wireType)
			}
			m.Unevictable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unevictable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mlocked", wireType)
			}
			m.Mlocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mlocked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTotal", wireType)
			}
			m.SwapTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapFree", wireType)
			}
			m.SwapFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dirty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writeback", wireType)
			}
			m.Writeback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Writeback |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonPages", wireType)
			}
			m.AnonPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnonPages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapped", wireType)
			}
			m.Mapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mapped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shmem", wireType)
			}
			m.Shmem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shmem |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slab", wireType)
			}
			m.Slab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slab |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SReclaimable", wireType)
			}
			m.SReclaimable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SReclaimable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SUnreclaim", wireType)
			}
			m.SUnreclaim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SUnreclaim |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelStack", wireType)
			}
			m.KernelStack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelStack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageTables", wireType)
			}
			m.PageTables = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageTables |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NfSunstable", wireType)
			}
			m.NfSunstable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NfSunstable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounce", wireType)
			}
			m.Bounce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bounce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritebackTmp", wireType)
			}
			m.WritebackTmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WritebackTmp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitLimit", wireType)
			}
			m.CommitLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedAs", wireType)
			}
			m.CommittedAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedAs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocTotal", wireType)
			}
			m.VmallocTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmallocTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocUsed", wireType)
			}
			m.VmallocUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmallocUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmallocChunk", wireType)
			}
			m.VmallocChunk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmallocChunk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareCorrupted", wireType)
			}
			m.HardwareCorrupted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareCorrupted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonHugePages", wireType)
			}
			m.AnonHugePages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnonHugePages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShmemHugePages", wireType)
			}
			m.ShmemHugePages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShmemHugePages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShmemPmdMapped", wireType)
			}
			m.ShmemPmdMapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShmemPmdMapped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmaTotal", wireType)
			}
			m.CmaTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmaTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmaFree", wireType)
			}
			m.CmaFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmaFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesTotal", wireType)
			}
			m.HugePagesTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesFree", wireType)
			}
			m.HugePagesFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesRsvd", wireType)
			}
			m.HugePagesRsvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesRsvd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HugePagesSurp", wireType)
			}
			m.HugePagesSurp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HugePagesSurp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hugepagesize", wireType)
			}
			m.Hugepagesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hugepagesize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectMap4K", wireType)
			}
			m.DirectMap4K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectMap4K |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectMap2M", wireType)
			}
			m.DirectMap2M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectMap2M |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectMap1G", wireType)
			}
			m.DirectMap1G = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirectMap1G |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

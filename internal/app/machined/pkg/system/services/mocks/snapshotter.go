// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by MockGen. DO NOT EDIT.
// Source: ~/go/pkg/mod/github.com/containerd/containerd@v1.6.4/snapshots/snapshotter.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	mount "github.com/containerd/containerd/v2/core/mount"
	snapshots "github.com/containerd/containerd/v2/core/snapshots"
	gomock "github.com/golang/mock/gomock"
)

// MockSnapshotter is a mock of Snapshotter interface.
type MockSnapshotter struct {
	ctrl     *gomock.Controller
	recorder *MockSnapshotterMockRecorder
}

// MockSnapshotterMockRecorder is the mock recorder for MockSnapshotter.
type MockSnapshotterMockRecorder struct {
	mock *MockSnapshotter
}

// NewMockSnapshotter creates a new mock instance.
func NewMockSnapshotter(ctrl *gomock.Controller) *MockSnapshotter {
	mock := &MockSnapshotter{ctrl: ctrl}
	mock.recorder = &MockSnapshotterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSnapshotter) EXPECT() *MockSnapshotterMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockSnapshotter) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSnapshotterMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSnapshotter)(nil).Close))
}

// Commit mocks base method.
func (m *MockSnapshotter) Commit(ctx context.Context, name, key string, opts ...snapshots.Opt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, name, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Commit", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockSnapshotterMockRecorder) Commit(ctx, name, key any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, name, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockSnapshotter)(nil).Commit), varargs...)
}

// Mounts mocks base method.
func (m *MockSnapshotter) Mounts(ctx context.Context, key string) ([]mount.Mount, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Mounts", ctx, key)
	ret0, _ := ret[0].([]mount.Mount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Mounts indicates an expected call of Mounts.
func (mr *MockSnapshotterMockRecorder) Mounts(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mounts", reflect.TypeOf((*MockSnapshotter)(nil).Mounts), ctx, key)
}

// Prepare mocks base method.
func (m *MockSnapshotter) Prepare(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, parent}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Prepare", varargs...)
	ret0, _ := ret[0].([]mount.Mount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prepare indicates an expected call of Prepare.
func (mr *MockSnapshotterMockRecorder) Prepare(ctx, key, parent any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, parent}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockSnapshotter)(nil).Prepare), varargs...)
}

// Remove mocks base method.
func (m *MockSnapshotter) Remove(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockSnapshotterMockRecorder) Remove(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockSnapshotter)(nil).Remove), ctx, key)
}

// Stat mocks base method.
func (m *MockSnapshotter) Stat(ctx context.Context, key string) (snapshots.Info, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", ctx, key)
	ret0, _ := ret[0].(snapshots.Info)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockSnapshotterMockRecorder) Stat(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockSnapshotter)(nil).Stat), ctx, key)
}

// Update mocks base method.
func (m *MockSnapshotter) Update(ctx context.Context, info snapshots.Info, fieldpaths ...string) (snapshots.Info, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, info}
	for _, a := range fieldpaths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(snapshots.Info)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockSnapshotterMockRecorder) Update(ctx, info any, fieldpaths ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, info}, fieldpaths...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockSnapshotter)(nil).Update), varargs...)
}

// Usage mocks base method.
func (m *MockSnapshotter) Usage(ctx context.Context, key string) (snapshots.Usage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Usage", ctx, key)
	ret0, _ := ret[0].(snapshots.Usage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Usage indicates an expected call of Usage.
func (mr *MockSnapshotterMockRecorder) Usage(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Usage", reflect.TypeOf((*MockSnapshotter)(nil).Usage), ctx, key)
}

// View mocks base method.
func (m *MockSnapshotter) View(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, parent}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "View", varargs...)
	ret0, _ := ret[0].([]mount.Mount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// View indicates an expected call of View.
func (mr *MockSnapshotterMockRecorder) View(ctx, key, parent any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, parent}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "View", reflect.TypeOf((*MockSnapshotter)(nil).View), varargs...)
}

// Walk mocks base method.
func (m *MockSnapshotter) Walk(ctx context.Context, fn snapshots.WalkFunc, filters ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn}
	for _, a := range filters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Walk", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockSnapshotterMockRecorder) Walk(ctx, fn any, filters ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn}, filters...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockSnapshotter)(nil).Walk), varargs...)
}

// MockCleaner is a mock of Cleaner interface.
type MockCleaner struct {
	ctrl     *gomock.Controller
	recorder *MockCleanerMockRecorder
}

// MockCleanerMockRecorder is the mock recorder for MockCleaner.
type MockCleanerMockRecorder struct {
	mock *MockCleaner
}

// NewMockCleaner creates a new mock instance.
func NewMockCleaner(ctrl *gomock.Controller) *MockCleaner {
	mock := &MockCleaner{ctrl: ctrl}
	mock.recorder = &MockCleanerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCleaner) EXPECT() *MockCleanerMockRecorder {
	return m.recorder
}

// Cleanup mocks base method.
func (m *MockCleaner) Cleanup(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cleanup", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Cleanup indicates an expected call of Cleanup.
func (mr *MockCleanerMockRecorder) Cleanup(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cleanup", reflect.TypeOf((*MockCleaner)(nil).Cleanup), ctx)
}
